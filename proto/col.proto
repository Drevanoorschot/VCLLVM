syntax = "proto2";
package vct.col.serialize;

message BigInt {
  required bytes data = 1;
}

message BigDecimal {
  required int32 scale = 1;
  required BigInt unscaled_value = 2;
}

message BitString {
  required bytes data = 1;
  required int32 skip_at_last_byte = 2;
}

message Ref {
  required int64 index = 1;
}

message ExpectedErrors {

}

message GlobalDeclaration {
  required int64 id = 1;

  oneof v {
    SimplificationRule simplification_rule = 2;
    AxiomaticDataType axiomatic_data_type = 3;
    VctClass vct_class = 4;
    VeyMontSeqProg vey_mont_seq_prog = 5;
    Model model = 6;
    Function function = 7;
    Procedure procedure = 8;
    Predicate predicate = 9;
    Enum enum = 10;
    ProverType prover_type = 11;
    ProverFunction prover_function = 12;
    CTranslationUnit c_translation_unit = 13;
    CGlobalDeclaration c_global_declaration = 14;
    CFunctionDefinition c_function_definition = 15;
    JavaNamespace java_namespace = 16;
    JavaClass java_class = 17;
    JavaInterface java_interface = 18;
    JavaAnnotationInterface java_annotation_interface = 19;
    JavaBipGlueContainer java_bip_glue_container = 20;
    BipGlue bip_glue = 21;
    BipPortSynchronization bip_port_synchronization = 22;
    BipTransitionSynchronization bip_transition_synchronization = 23;
    LlvmFunctionDefinition llvm_function_definition = 24;
    SilverField silver_field = 25;
  }
}

message ClassDeclaration {
  required int64 id = 1;

  oneof v {
    InstanceFunction instance_function = 2;
    InstanceMethod instance_method = 3;
    InstancePredicate instance_predicate = 4;
    InstanceField instance_field = 5;
    RunMethod run_method = 6;
    InstanceOperatorFunction instance_operator_function = 7;
    InstanceOperatorMethod instance_operator_method = 8;
    JavaSharedInitialization java_shared_initialization = 9;
    JavaFields java_fields = 10;
    JavaConstructor java_constructor = 11;
    JavaMethod java_method = 12;
    JavaAnnotationMethod java_annotation_method = 13;
    BipIncomingData bip_incoming_data = 14;
    BipOutgoingData bip_outgoing_data = 15;
    BipStatePredicate bip_state_predicate = 16;
    BipTransition bip_transition = 17;
    BipGuard bip_guard = 18;
    BipComponent bip_component = 19;
    BipPort bip_port = 20;
    PVLConstructor p_v_l_constructor = 21;
  }
}

message ADTDeclaration {
  required int64 id = 1;

  oneof v {
    ADTAxiom a_d_t_axiom = 2;
    ADTFunction a_d_t_function = 3;
  }
}

message ModelDeclaration {
  required int64 id = 1;

  oneof v {
    ModelField model_field = 2;
    ModelProcess model_process = 3;
    ModelAction model_action = 4;
  }
}

message Type {
  oneof v {
    TNotAValue t_not_a_value = 1;
    TUnion t_union = 2;
    TArray t_array = 3;
    TPointer t_pointer = 4;
    TType t_type = 5;
    TVar t_var = 6;
    TSeq t_seq = 7;
    TSet t_set = 8;
    TBag t_bag = 9;
    TMap t_map = 10;
    TOption t_option = 11;
    TTuple t_tuple = 12;
    TEither t_either = 13;
    TMatrix t_matrix = 14;
    TAny t_any = 15;
    TNothing t_nothing = 16;
    TVoid t_void = 17;
    TNull t_null = 18;
    TBool t_bool = 19;
    TResource t_resource = 20;
    TChar t_char = 21;
    TString t_string = 22;
    TRef t_ref = 23;
    TProcess t_process = 24;
    TInt t_int = 25;
    TBoundedInt t_bounded_int = 26;
    TFloat t_float = 27;
    TRational t_rational = 28;
    TFraction t_fraction = 29;
    TZFraction t_z_fraction = 30;
    TModel t_model = 31;
    TClass t_class = 32;
    TSeqProg t_seq_prog = 33;
    TVeyMontThread t_vey_mont_thread = 34;
    TAnyClass t_any_class = 35;
    TAxiomatic t_axiomatic = 36;
    TEnum t_enum = 37;
    TProverType t_prover_type = 38;
    TSmtlibArray t_smtlib_array = 39;
    TSmtlibBitVector t_smtlib_bit_vector = 40;
    TSmtlibRoundingMode t_smtlib_rounding_mode = 41;
    TSmtlibFloatingPoint t_smtlib_floating_point = 42;
    TSmtlibString t_smtlib_string = 43;
    TSmtlibRegLan t_smtlib_reg_lan = 44;
    TSmtlibSeq t_smtlib_seq = 45;
    CPrimitiveType c_primitive_type = 46;
    CTPointer c_t_pointer = 47;
    CTArray c_t_array = 48;
    CTCudaVec c_t_cuda_vec = 49;
    JavaNamedType java_named_type = 50;
    JavaTClass java_t_class = 51;
    JavaWildcard java_wildcard = 52;
    PVLNamedType p_v_l_named_type = 53;
    SilverPartialTAxiomatic silver_partial_t_axiomatic = 54;
  }
}

message ParRegion {
  oneof v {
    ParParallel par_parallel = 1;
    ParSequential par_sequential = 2;
    ParBlock par_block = 3;
  }
}

message LoopContract {
  oneof v {
    LoopInvariant loop_invariant = 1;
    IterationContract iteration_contract = 2;
  }
}

message Statement {
  oneof v {
    LocalDecl local_decl = 1;
    SpecIgnoreStart spec_ignore_start = 2;
    SpecIgnoreEnd spec_ignore_end = 3;
    Assign assign = 4;
    Send send = 5;
    Recv recv = 6;
    DefaultCase default_case = 7;
    Case case = 8;
    Label label = 9;
    Goto goto = 10;
    Exhale exhale = 11;
    VctAssert vct_assert = 12;
    Refute refute = 13;
    Inhale inhale = 14;
    Assume assume = 15;
    Wait wait = 16;
    Notify notify = 17;
    Fork fork = 18;
    Join join = 19;
    Lock lock = 20;
    Unlock unlock = 21;
    Commit commit = 22;
    Fold fold = 23;
    Unfold unfold = 24;
    WandApply wand_apply = 25;
    Havoc havoc = 26;
    FramedProof framed_proof = 27;
    Extract extract = 28;
    Eval eval = 29;
    InvokeProcedure invoke_procedure = 30;
    InvokeMethod invoke_method = 31;
    Return return = 32;
    Throw throw = 33;
    Break break = 34;
    Continue continue = 35;
    Block block = 36;
    Scope scope = 37;
    Branch branch = 38;
    IndetBranch indet_branch = 39;
    Switch switch = 40;
    Loop loop = 41;
    TryCatchFinally try_catch_finally = 42;
    Synchronized synchronized = 43;
    ParInvariant par_invariant = 44;
    ParAtomic par_atomic = 45;
    ParBarrier par_barrier = 46;
    ParStatement par_statement = 47;
    VecBlock vec_block = 48;
    WandPackage wand_package = 49;
    ModelDo model_do = 50;
    VeyMontCommExpression vey_mont_comm_expression = 51;
    VeyMontAssignExpression vey_mont_assign_expression = 52;
    CDeclarationStatement c_declaration_statement = 53;
    CGoto c_goto = 54;
    GpgpuBarrier gpgpu_barrier = 55;
    GpgpuAtomic gpgpu_atomic = 56;
    JavaLocalDeclarationStatement java_local_declaration_statement = 57;
    LlvmLoop llvm_loop = 58;
    SilverNewRef silver_new_ref = 59;
    SilverFieldAssign silver_field_assign = 60;
    SilverLocalAssign silver_local_assign = 61;
  }
}

message ProverLanguage {
  oneof v {
    SmtLib smt_lib = 1;
    Boogie boogie = 2;
  }
}

message Operator {
  oneof v {
    OperatorLeftPlus operator_left_plus = 1;
    OperatorRightPlus operator_right_plus = 2;
  }
}

message DecreasesClause {
  oneof v {
    DecreasesClauseAssume decreases_clause_assume = 1;
    DecreasesClauseNoRecursion decreases_clause_no_recursion = 2;
    DecreasesClauseTuple decreases_clause_tuple = 3;
  }
}

message AccountedPredicate {
  oneof v {
    UnitAccountedPredicate unit_accounted_predicate = 1;
    SplitAccountedPredicate split_accounted_predicate = 2;
  }
}

message FieldFlag {
  oneof v {
    Final final = 1;
  }
}

message Coercion {
  oneof v {
    CoerceIdentity coerce_identity = 1;
    CoercionSequence coercion_sequence = 2;
    CoerceNothingSomething coerce_nothing_something = 3;
    CoerceSomethingAny coerce_something_any = 4;
    CoerceJoinUnion coerce_join_union = 5;
    CoerceSelectUnion coerce_select_union = 6;
    CoerceBoolResource coerce_bool_resource = 7;
    CoerceNullRef coerce_null_ref = 8;
    CoerceNullArray coerce_null_array = 9;
    CoerceNullClass coerce_null_class = 10;
    CoerceNullJavaClass coerce_null_java_class = 11;
    CoerceNullAnyClass coerce_null_any_class = 12;
    CoerceNullPointer coerce_null_pointer = 13;
    CoerceNullEnum coerce_null_enum = 14;
    CoerceCArrayPointer coerce_c_array_pointer = 15;
    CoerceFracZFrac coerce_frac_z_frac = 16;
    CoerceZFracRat coerce_z_frac_rat = 17;
    CoerceFloatRat coerce_float_rat = 18;
    CoerceIntRat coerce_int_rat = 19;
    CoerceIncreasePrecision coerce_increase_precision = 20;
    CoerceWidenBound coerce_widen_bound = 21;
    CoerceUnboundInt coerce_unbound_int = 22;
    CoerceBoundIntFrac coerce_bound_int_frac = 23;
    CoerceBoundIntZFrac coerce_bound_int_z_frac = 24;
    CoerceBoundIntFloat coerce_bound_int_float = 25;
    CoerceSupports coerce_supports = 26;
    CoerceJavaSupports coerce_java_supports = 27;
    CoerceClassAnyClass coerce_class_any_class = 28;
    CoerceJavaClassAnyClass coerce_java_class_any_class = 29;
    CoerceCPrimitiveToCol coerce_c_primitive_to_col = 30;
    CoerceColToCPrimitive coerce_col_to_c_primitive = 31;
    CoerceMapOption coerce_map_option = 32;
    CoerceMapTuple coerce_map_tuple = 33;
    CoerceMapEither coerce_map_either = 34;
    CoerceMapSeq coerce_map_seq = 35;
    CoerceMapSet coerce_map_set = 36;
    CoerceMapBag coerce_map_bag = 37;
    CoerceMapMatrix coerce_map_matrix = 38;
    CoerceMapMap coerce_map_map = 39;
    CoerceMapType coerce_map_type = 40;
    CoerceRatZFrac coerce_rat_z_frac = 41;
    CoerceZFracFrac coerce_z_frac_frac = 42;
  }
}

message Expr {
  oneof v {
    IntegerValue integer_value = 1;
    BooleanValue boolean_value = 2;
    FloatValue float_value = 3;
    StringValue string_value = 4;
    CharValue char_value = 5;
    LiteralSeq literal_seq = 6;
    LiteralSet literal_set = 7;
    LiteralBag literal_bag = 8;
    LiteralTuple literal_tuple = 9;
    LiteralMap literal_map = 10;
    UntypedLiteralSeq untyped_literal_seq = 11;
    UntypedLiteralSet untyped_literal_set = 12;
    UntypedLiteralBag untyped_literal_bag = 13;
    Void void = 14;
    Null null = 15;
    NoPerm no_perm = 16;
    WritePerm write_perm = 17;
    OptSome opt_some = 18;
    OptSomeTyped opt_some_typed = 19;
    OptNone opt_none = 20;
    OptNoneTyped opt_none_typed = 21;
    Range range = 22;
    EitherLeft either_left = 23;
    EitherRight either_right = 24;
    MapCons map_cons = 25;
    AmbiguousThis ambiguous_this = 26;
    ThisObject this_object = 27;
    ThisModel this_model = 28;
    ThisSeqProg this_seq_prog = 29;
    AmbiguousResult ambiguous_result = 30;
    Result result = 31;
    CurrentThreadId current_thread_id = 32;
    LocalThreadId local_thread_id = 33;
    GlobalThreadId global_thread_id = 34;
    Any any = 35;
    ReadPerm read_perm = 36;
    Values values = 37;
    MapEq map_eq = 38;
    MapDisjoint map_disjoint = 39;
    MapKeySet map_key_set = 40;
    MapValueSet map_value_set = 41;
    MapItemSet map_item_set = 42;
    MapRemove map_remove = 43;
    Forall forall = 44;
    Starall starall = 45;
    Exists exists = 46;
    Sum sum = 47;
    Product product = 48;
    ForPerm for_perm = 49;
    ForPermWithValue for_perm_with_value = 50;
    Let let = 51;
    InlinePattern inline_pattern = 52;
    ScopedExpr scoped_expr = 53;
    Local local = 54;
    EnumUse enum_use = 55;
    Deref deref = 56;
    ModelDeref model_deref = 57;
    DerefPointer deref_pointer = 58;
    DerefVeyMontThread deref_vey_mont_thread = 59;
    PointerAdd pointer_add = 60;
    AddrOf addr_of = 61;
    FunctionOf function_of = 62;
    ApplyCoercion apply_coercion = 63;
    ADTFunctionInvocation a_d_t_function_invocation = 64;
    ProverFunctionInvocation prover_function_invocation = 65;
    PredicateApply predicate_apply = 66;
    InstancePredicateApply instance_predicate_apply = 67;
    CoalesceInstancePredicateApply coalesce_instance_predicate_apply = 68;
    ProcedureInvocation procedure_invocation = 69;
    MethodInvocation method_invocation = 70;
    FunctionInvocation function_invocation = 71;
    InstanceFunctionInvocation instance_function_invocation = 72;
    UMinus u_minus = 73;
    BitNot bit_not = 74;
    Not not = 75;
    AmbiguousMult ambiguous_mult = 76;
    AmbiguousPlus ambiguous_plus = 77;
    AmbiguousMinus ambiguous_minus = 78;
    AmbiguousOr ambiguous_or = 79;
    AmbiguousComputationalOr ambiguous_computational_or = 80;
    AmbiguousComputationalXor ambiguous_computational_xor = 81;
    AmbiguousComputationalAnd ambiguous_computational_and = 82;
    ComputationalOr computational_or = 83;
    ComputationalXor computational_xor = 84;
    ComputationalAnd computational_and = 85;
    Exp exp = 86;
    Plus plus = 87;
    Minus minus = 88;
    Mult mult = 89;
    Div div = 90;
    FloorDiv floor_div = 91;
    Mod mod = 92;
    StringConcat string_concat = 93;
    BitAnd bit_and = 94;
    BitOr bit_or = 95;
    BitXor bit_xor = 96;
    BitShl bit_shl = 97;
    BitShr bit_shr = 98;
    BitUShr bit_u_shr = 99;
    And and = 100;
    Or or = 101;
    Implies implies = 102;
    Star star = 103;
    Wand wand = 104;
    Scale scale = 105;
    ScaleByParBlock scale_by_par_block = 106;
    VeyMontCondition vey_mont_condition = 107;
    PolarityDependent polarity_dependent = 108;
    Unfolding unfolding = 109;
    Perm perm = 110;
    PointsTo points_to = 111;
    CurPerm cur_perm = 112;
    Value value = 113;
    ValidArray valid_array = 114;
    ValidMatrix valid_matrix = 115;
    PermPointer perm_pointer = 116;
    PermPointerIndex perm_pointer_index = 117;
    Eq eq = 118;
    Neq neq = 119;
    AmbiguousGreater ambiguous_greater = 120;
    AmbiguousLess ambiguous_less = 121;
    AmbiguousGreaterEq ambiguous_greater_eq = 122;
    AmbiguousLessEq ambiguous_less_eq = 123;
    Greater greater = 124;
    Less less = 125;
    GreaterEq greater_eq = 126;
    LessEq less_eq = 127;
    SubSet sub_set = 128;
    SubSetEq sub_set_eq = 129;
    SubBag sub_bag = 130;
    SubBagEq sub_bag_eq = 131;
    Select select = 132;
    NewObject new_object = 133;
    NewArray new_array = 134;
    Old old = 135;
    AmbiguousSubscript ambiguous_subscript = 136;
    SeqSubscript seq_subscript = 137;
    ArraySubscript array_subscript = 138;
    PointerSubscript pointer_subscript = 139;
    Length length = 140;
    Size size = 141;
    PointerBlockLength pointer_block_length = 142;
    PointerBlockOffset pointer_block_offset = 143;
    PointerLength pointer_length = 144;
    SharedMemSize shared_mem_size = 145;
    NdIndex nd_index = 146;
    NdPartialIndex nd_partial_index = 147;
    NdLength nd_length = 148;
    Cons cons = 149;
    Head head = 150;
    Tail tail = 151;
    Drop drop = 152;
    Take take = 153;
    Slice slice = 154;
    SeqUpdate seq_update = 155;
    Concat concat = 156;
    RemoveAt remove_at = 157;
    VctEmpty vct_empty = 158;
    SetIntersection set_intersection = 159;
    BagLargestCommon bag_largest_common = 160;
    SetMinus set_minus = 161;
    BagMinus bag_minus = 162;
    SetUnion set_union = 163;
    BagAdd bag_add = 164;
    AmbiguousMember ambiguous_member = 165;
    SetMember set_member = 166;
    SeqMember seq_member = 167;
    MapMember map_member = 168;
    BagMemberCount bag_member_count = 169;
    Permutation permutation = 170;
    OptEmpty opt_empty = 171;
    OptGet opt_get = 172;
    OptGetOrElse opt_get_or_else = 173;
    MapGet map_get = 174;
    TupGet tup_get = 175;
    GetLeft get_left = 176;
    GetRight get_right = 177;
    IsLeft is_left = 178;
    IsRight is_right = 179;
    VectorSum vector_sum = 180;
    VectorCompare vector_compare = 181;
    VectorRepeat vector_repeat = 182;
    MatrixSum matrix_sum = 183;
    MatrixCompare matrix_compare = 184;
    MatrixRepeat matrix_repeat = 185;
    CastFloat cast_float = 186;
    TypeValue type_value = 187;
    TypeOf type_of = 188;
    VctInstanceOf vct_instance_of = 189;
    Cast cast = 190;
    SubType sub_type = 191;
    SuperType super_type = 192;
    IndeterminateInteger indeterminate_integer = 193;
    PreAssignExpression pre_assign_expression = 194;
    PostAssignExpression post_assign_expression = 195;
    With with = 196;
    Then then = 197;
    Held held = 198;
    Committed committed = 199;
    IdleToken idle_token = 200;
    JoinToken join_token = 201;
    EmptyProcess empty_process = 202;
    ActionApply action_apply = 203;
    ProcessApply process_apply = 204;
    ProcessSeq process_seq = 205;
    ProcessChoice process_choice = 206;
    ProcessPar process_par = 207;
    ProcessSelect process_select = 208;
    ModelNew model_new = 209;
    ModelState model_state = 210;
    ModelAbstractState model_abstract_state = 211;
    ModelCreate model_create = 212;
    ModelDestroy model_destroy = 213;
    ModelSplit model_split = 214;
    ModelMerge model_merge = 215;
    ModelChoose model_choose = 216;
    ModelPerm model_perm = 217;
    ActionPerm action_perm = 218;
    SmtlibSelect smtlib_select = 219;
    SmtlibStore smtlib_store = 220;
    SmtlibBitvecLiteral smtlib_bitvec_literal = 221;
    SmtlibConcat smtlib_concat = 222;
    SmtlibExtract smtlib_extract = 223;
    SmtlibBvNot smtlib_bv_not = 224;
    SmtlibBvAnd smtlib_bv_and = 225;
    SmtlibBvOr smtlib_bv_or = 226;
    SmtlibBvNeg smtlib_bv_neg = 227;
    SmtlibBvAdd smtlib_bv_add = 228;
    SmtlibBvMul smtlib_bv_mul = 229;
    SmtlibBvUDiv smtlib_bv_u_div = 230;
    SmtlibBvURem smtlib_bv_u_rem = 231;
    SmtlibBvShl smtlib_bv_shl = 232;
    SmtlibBvShr smtlib_bv_shr = 233;
    SmtlibBvULt smtlib_bv_u_lt = 234;
    SmtlibRNE smtlib_r_n_e = 235;
    SmtlibRNA smtlib_r_n_a = 236;
    SmtlibRTP smtlib_r_t_p = 237;
    SmtlibRTN smtlib_r_t_n = 238;
    SmtlibRTZ smtlib_r_t_z = 239;
    SmtlibFp smtlib_fp = 240;
    SmtlibFpAbs smtlib_fp_abs = 241;
    SmtlibFpNeg smtlib_fp_neg = 242;
    SmtlibFpAdd smtlib_fp_add = 243;
    SmtlibFpSub smtlib_fp_sub = 244;
    SmtlibFpMul smtlib_fp_mul = 245;
    SmtlibFpDiv smtlib_fp_div = 246;
    SmtlibFpFma smtlib_fp_fma = 247;
    SmtlibFpSqrt smtlib_fp_sqrt = 248;
    SmtlibFpRem smtlib_fp_rem = 249;
    SmtlibFpRoundToIntegral smtlib_fp_round_to_integral = 250;
    SmtlibFpMin smtlib_fp_min = 251;
    SmtlibFpMax smtlib_fp_max = 252;
    SmtlibFpLeq smtlib_fp_leq = 253;
    SmtlibFpLt smtlib_fp_lt = 254;
    SmtlibFpGeq smtlib_fp_geq = 255;
    SmtlibFpGt smtlib_fp_gt = 256;
    SmtlibFpEq smtlib_fp_eq = 257;
    SmtlibFpIsNormal smtlib_fp_is_normal = 258;
    SmtlibFpIsSubnormal smtlib_fp_is_subnormal = 259;
    SmtlibFpIsZero smtlib_fp_is_zero = 260;
    SmtlibFpIsInfinite smtlib_fp_is_infinite = 261;
    SmtlibFpIsNaN smtlib_fp_is_na_n = 262;
    SmtlibFpIsNegative smtlib_fp_is_negative = 263;
    SmtlibFpIsPositive smtlib_fp_is_positive = 264;
    SmtlibToFp smtlib_to_fp = 265;
    SmtlibFpCast smtlib_fp_cast = 266;
    SmtlibFpFromReal smtlib_fp_from_real = 267;
    SmtlibFpFromSInt smtlib_fp_from_s_int = 268;
    SmtlibFpFromUInt smtlib_fp_from_u_int = 269;
    SmtlibFpToReal smtlib_fp_to_real = 270;
    SmtlibFpToSInt smtlib_fp_to_s_int = 271;
    SmtlibFpToUInt smtlib_fp_to_u_int = 272;
    SmtlibLiteralString smtlib_literal_string = 273;
    SmtlibStrConcat smtlib_str_concat = 274;
    SmtlibStrLen smtlib_str_len = 275;
    SmtlibStrLt smtlib_str_lt = 276;
    SmtlibStrLeq smtlib_str_leq = 277;
    SmtlibStrAt smtlib_str_at = 278;
    SmtlibSubstr smtlib_substr = 279;
    SmtlibStrPrefixOf smtlib_str_prefix_of = 280;
    SmtlibStrSuffixOf smtlib_str_suffix_of = 281;
    SmtlibStrContains smtlib_str_contains = 282;
    SmtlibStrIndexOf smtlib_str_index_of = 283;
    SmtlibStrReplace smtlib_str_replace = 284;
    SmtlibStrReplaceAll smtlib_str_replace_all = 285;
    SmtlibStrReplaceRe smtlib_str_replace_re = 286;
    SmtlibStrReplaceReAll smtlib_str_replace_re_all = 287;
    SmtlibStrIsDigit smtlib_str_is_digit = 288;
    SmtlibStrToCode smtlib_str_to_code = 289;
    SmtlibStrFromCode smtlib_str_from_code = 290;
    SmtlibStrToInt smtlib_str_to_int = 291;
    SmtlibStrFromInt smtlib_str_from_int = 292;
    SmtlibReFromStr smtlib_re_from_str = 293;
    SmtlibReContains smtlib_re_contains = 294;
    SmtlibReNone smtlib_re_none = 295;
    SmtlibReAll smtlib_re_all = 296;
    SmtlibReAllChar smtlib_re_all_char = 297;
    SmtlibReConcat smtlib_re_concat = 298;
    SmtlibReUnion smtlib_re_union = 299;
    SmtlibReInter smtlib_re_inter = 300;
    SmtlibReStar smtlib_re_star = 301;
    SmtlibReComp smtlib_re_comp = 302;
    SmtlibReDiff smtlib_re_diff = 303;
    SmtlibRePlus smtlib_re_plus = 304;
    SmtlibReOpt smtlib_re_opt = 305;
    SmtlibReRange smtlib_re_range = 306;
    SmtlibReRepeat smtlib_re_repeat = 307;
    SmtlibReRepeatRange smtlib_re_repeat_range = 308;
    Z3BvSub z3_bv_sub = 309;
    Z3BvSRem z3_bv_s_rem = 310;
    Z3BvSMod z3_bv_s_mod = 311;
    Z3BvSShr z3_bv_s_shr = 312;
    Z3BvNand z3_bv_nand = 313;
    Z3BvNor z3_bv_nor = 314;
    Z3BvXnor z3_bv_xnor = 315;
    Z3ArrayConst z3_array_const = 316;
    Z3ArrayOfFunction z3_array_of_function = 317;
    Z3ArrayMap z3_array_map = 318;
    Z3SeqEmpty z3_seq_empty = 319;
    Z3SeqUnit z3_seq_unit = 320;
    Z3SeqConcat z3_seq_concat = 321;
    Z3SeqLen z3_seq_len = 322;
    Z3SeqExtract z3_seq_extract = 323;
    Z3SeqAt z3_seq_at = 324;
    Z3SeqNth z3_seq_nth = 325;
    Z3SeqContains z3_seq_contains = 326;
    Z3SeqPrefixOf z3_seq_prefix_of = 327;
    Z3SeqSuffixOf z3_seq_suffix_of = 328;
    Z3SeqReplace z3_seq_replace = 329;
    Z3SeqMap z3_seq_map = 330;
    Z3SeqMapI z3_seq_map_i = 331;
    Z3SeqFoldl z3_seq_foldl = 332;
    Z3SeqFoldlI z3_seq_foldl_i = 333;
    Z3TransitiveClosure z3_transitive_closure = 334;
    CLocal c_local = 335;
    CInvocation c_invocation = 336;
    CStructAccess c_struct_access = 337;
    CStructDeref c_struct_deref = 338;
    GpgpuCudaKernelInvocation gpgpu_cuda_kernel_invocation = 339;
    CCast c_cast = 340;
    JavaLocal java_local = 341;
    JavaDeref java_deref = 342;
    JavaLiteralArray java_literal_array = 343;
    JavaInvocation java_invocation = 344;
    JavaNewClass java_new_class = 345;
    JavaNewLiteralArray java_new_literal_array = 346;
    JavaNewDefaultArray java_new_default_array = 347;
    JavaStringValue java_string_value = 348;
    JavaBipGlue java_bip_glue = 349;
    BipLocalIncomingData bip_local_incoming_data = 350;
    BipGuardInvocation bip_guard_invocation = 351;
    LlvmFunctionInvocation llvm_function_invocation = 352;
    PVLLocal p_v_l_local = 353;
    PVLDeref p_v_l_deref = 354;
    PVLInvocation p_v_l_invocation = 355;
    PVLNew p_v_l_new = 356;
    SilverDeref silver_deref = 357;
    SilverIntToRat silver_int_to_rat = 358;
    SilverNull silver_null = 359;
    SilverSeqSize silver_seq_size = 360;
    SilverSetSize silver_set_size = 361;
    SilverBagSize silver_bag_size = 362;
    SilverMapSize silver_map_size = 363;
    SilverCurFieldPerm silver_cur_field_perm = 364;
    SilverCurPredPerm silver_cur_pred_perm = 365;
    SilverPartialADTFunctionInvocation silver_partial_a_d_t_function_invocation = 366;
    SilverUntypedNonemptyLiteralMap silver_untyped_nonempty_literal_map = 367;
  }
}

message Location {
  oneof v {
    FieldLocation field_location = 1;
    ModelLocation model_location = 2;
    SilverFieldLocation silver_field_location = 3;
    ArrayLocation array_location = 4;
    PointerLocation pointer_location = 5;
    PredicateLocation predicate_location = 6;
    InstancePredicateLocation instance_predicate_location = 7;
    AmbiguousLocation ambiguous_location = 8;
  }
}

message SmtlibFunctionSymbol {
  oneof v {
    SmtlibADTFunctionSymbol smtlib_a_d_t_function_symbol = 1;
    SmtlibProverFunctionSymbol smtlib_prover_function_symbol = 2;
  }
}

message CDeclarationSpecifier {
  oneof v {
    CPure c_pure = 1;
    CInline c_inline = 2;
    CTypedef c_typedef = 3;
    CExtern c_extern = 4;
    CStatic c_static = 5;
    GPULocal g_p_u_local = 6;
    GPUGlobal g_p_u_global = 7;
    CVoid c_void = 8;
    CChar c_char = 9;
    CShort c_short = 10;
    CInt c_int = 11;
    CLong c_long = 12;
    CSigned c_signed = 13;
    CUnsigned c_unsigned = 14;
    CBool c_bool = 15;
    CTypedefName c_typedef_name = 16;
    CSpecificationType c_specification_type = 17;
    CTypeQualifierDeclarationSpecifier c_type_qualifier_declaration_specifier = 18;
    CUDAKernel c_u_d_a_kernel = 19;
    OpenCLKernel open_c_l_kernel = 20;
  }
}

message CTypeQualifier {
  oneof v {
    CConst c_const = 1;
    CRestrict c_restrict = 2;
    CVolatile c_volatile = 3;
    CAtomic c_atomic = 4;
  }
}

message CDeclarator {
  oneof v {
    CPointerDeclarator c_pointer_declarator = 1;
    CArrayDeclarator c_array_declarator = 2;
    CTypedFunctionDeclarator c_typed_function_declarator = 3;
    CAnonymousFunctionDeclarator c_anonymous_function_declarator = 4;
    CName c_name = 5;
  }
}

message GpuMemoryFence {
  oneof v {
    GpuLocalMemoryFence gpu_local_memory_fence = 1;
    GpuGlobalMemoryFence gpu_global_memory_fence = 2;
    GpuZeroMemoryFence gpu_zero_memory_fence = 3;
  }
}

message JavaModifier {
  oneof v {
    JavaPublic java_public = 1;
    JavaProtected java_protected = 2;
    JavaPrivate java_private = 3;
    JavaStatic java_static = 4;
    JavaAbstract java_abstract = 5;
    JavaFinal java_final = 6;
    JavaStrictFP java_strict_f_p = 7;
    JavaNative java_native = 8;
    JavaSynchronized java_synchronized = 9;
    JavaTransient java_transient = 10;
    JavaVolatile java_volatile = 11;
    JavaAnnotation java_annotation = 12;
    JavaPure java_pure = 13;
    JavaInline java_inline = 14;
    JavaBipAnnotation java_bip_annotation = 15;
  }
}

message JavaBipGlueElement {
  oneof v {
    JavaBipGlueRequires java_bip_glue_requires = 1;
    JavaBipGlueAccepts java_bip_glue_accepts = 2;
    JavaBipGlueSynchron java_bip_glue_synchron = 3;
    JavaBipGlueDataWire java_bip_glue_data_wire = 4;
  }
}

message BipPortType {
  oneof v {
    BipEnforceable bip_enforceable = 1;
    BipSpontaneous bip_spontaneous = 2;
    BipInternal bip_internal = 3;
  }
}

message LlvmLoopContract {
  oneof v {
    LlvmLoopInvariant llvm_loop_invariant = 1;
  }
}

message SimplificationRule {
  required string origin = 1;
  required Expr axiom = 2;
}

message AxiomaticDataType {
  required string origin = 1;
  repeated ADTDeclaration decls = 2;
  repeated Variable type_args = 3;
}

message VctClass {
  required string origin = 1;
  repeated ClassDeclaration declarations = 2;
  repeated Ref supports = 3;
  required Expr intrinsic_lock_invariant = 4;
}

message VeyMontSeqProg {
  required string origin = 1;
  required ApplicableContract contract = 2;
  repeated Variable prog_args = 3;
  repeated VeyMontThread threads = 4;
  required ClassDeclaration run_method = 5;
  repeated ClassDeclaration methods = 6;
}

message VeyMontThread {
  required int64 id = 1;
  required string origin = 2;
  required Type thread_type = 3;
  repeated Expr args = 4;
}

message Model {
  required string origin = 1;
  repeated ModelDeclaration declarations = 2;
}

message Function {
  required string origin = 1;
  required Type return_type = 2;
  repeated Variable args = 3;
  repeated Variable type_args = 4;
  optional Expr body = 5;
  required ApplicableContract contract = 6;
  required bool inline = 7;
  required bool thread_local = 8;
}

message Procedure {
  required string origin = 1;
  required Type return_type = 2;
  repeated Variable args = 3;
  repeated Variable out_args = 4;
  repeated Variable type_args = 5;
  optional Statement body = 6;
  required ApplicableContract contract = 7;
  required bool inline = 8;
  required bool pure = 9;
}

message Predicate {
  required string origin = 1;
  repeated Variable args = 2;
  optional Expr body = 3;
  required bool thread_local = 4;
  required bool inline = 5;
}

message Enum {
  required string origin = 1;
  repeated EnumConstant constants = 2;
}

message EnumConstant {
  required int64 id = 1;
  required string origin = 2;
}

message ProverType {
  required string origin = 1;
  repeated ProverLanguageString interpretation = 2;
}

message ProverFunction {
  required string origin = 1;
  repeated ProverLanguageString interpretation = 2;
  repeated Variable args = 3;
  required Type return_type = 4;
}

message InstanceFunction {
  required string origin = 1;
  required Type return_type = 2;
  repeated Variable args = 3;
  repeated Variable type_args = 4;
  optional Expr body = 5;
  required ApplicableContract contract = 6;
  required bool inline = 7;
  required bool thread_local = 8;
}

message InstanceMethod {
  required string origin = 1;
  required Type return_type = 2;
  repeated Variable args = 3;
  repeated Variable out_args = 4;
  repeated Variable type_args = 5;
  optional Statement body = 6;
  required ApplicableContract contract = 7;
  required bool inline = 8;
  required bool pure = 9;
}

message InstancePredicate {
  required string origin = 1;
  repeated Variable args = 2;
  optional Expr body = 3;
  required bool thread_local = 4;
  required bool inline = 5;
}

message InstanceField {
  required string origin = 1;
  required Type t = 2;
  repeated FieldFlag flags = 3;
}

message RunMethod {
  required string origin = 1;
  optional Statement body = 2;
  required ApplicableContract contract = 3;
}

message InstanceOperatorFunction {
  required string origin = 1;
  required Type return_type = 2;
  required Operator operator = 3;
  repeated Variable args = 4;
  optional Expr body = 5;
  required ApplicableContract contract = 6;
  required bool inline = 7;
  required bool thread_local = 8;
}

message InstanceOperatorMethod {
  required string origin = 1;
  required Type return_type = 2;
  required Operator operator = 3;
  repeated Variable args = 4;
  optional Statement body = 5;
  required ApplicableContract contract = 6;
  required bool inline = 7;
  required bool pure = 8;
}

message ModelField {
  required string origin = 1;
  required Type t = 2;
}

message ModelProcess {
  required string origin = 1;
  repeated Variable args = 2;
  required Expr impl = 3;
  required Expr requires = 4;
  required Expr ensures = 5;
  repeated Ref modifies = 6;
  repeated Ref accessible = 7;
}

message ModelAction {
  required string origin = 1;
  repeated Variable args = 2;
  required Expr requires = 3;
  required Expr ensures = 4;
  repeated Ref modifies = 5;
  repeated Ref accessible = 6;
}

message ADTAxiom {
  required string origin = 1;
  required Expr axiom = 2;
}

message ADTFunction {
  required string origin = 1;
  repeated Variable args = 2;
  required Type return_type = 3;
}

message Variable {
  required int64 id = 1;
  required string origin = 2;
  required Type t = 3;
}

message LabelDecl {
  required int64 id = 1;
  required string origin = 2;
}

message SendDecl {
  required int64 id = 1;
  required string origin = 2;
}

message ParBlockDecl {
  required int64 id = 1;
  required string origin = 2;
}

message ParInvariantDecl {
  required int64 id = 1;
  required string origin = 2;
}

message CParam {
  required int64 id = 1;
  required string origin = 2;
  repeated CDeclarationSpecifier specifiers = 3;
  required CDeclarator declarator = 4;
}

message CTranslationUnit {
  required string origin = 1;
  repeated GlobalDeclaration declarations = 2;
}

message CGlobalDeclaration {
  required string origin = 1;
  required CDeclaration decl = 2;
}

message CLocalDeclaration {
  required int64 id = 1;
  required string origin = 2;
  required CDeclaration decl = 3;
}

message CFunctionDefinition {
  required string origin = 1;
  required ApplicableContract contract = 2;
  repeated CDeclarationSpecifier specs = 3;
  required CDeclarator declarator = 4;
  required Statement body = 5;
}

message JavaNamespace {
  required string origin = 1;
  optional JavaName pkg = 2;
  repeated JavaImport imports = 3;
  repeated GlobalDeclaration declarations = 4;
}

message JavaClass {
  required string origin = 1;
  required string name = 2;
  repeated JavaModifier modifiers = 3;
  repeated Variable type_params = 4;
  required Expr intrinsic_lock_invariant = 5;
  required Type ext = 6;
  repeated Type imp = 7;
  repeated ClassDeclaration decls = 8;
}

message JavaInterface {
  required string origin = 1;
  required string name = 2;
  repeated JavaModifier modifiers = 3;
  repeated Variable type_params = 4;
  repeated Type ext = 5;
  repeated ClassDeclaration decls = 6;
}

message JavaAnnotationInterface {
  required string origin = 1;
  required string name = 2;
  repeated JavaModifier modifiers = 3;
  required Type ext = 4;
  repeated ClassDeclaration decls = 5;
}

message JavaSharedInitialization {
  required string origin = 1;
  required bool is_static = 2;
  required Statement initialization = 3;
}

message JavaFields {
  required string origin = 1;
  repeated JavaModifier modifiers = 2;
  required Type t = 3;
  repeated JavaVariableDeclaration decls = 4;
}

message JavaConstructor {
  required string origin = 1;
  repeated JavaModifier modifiers = 2;
  required string name = 3;
  repeated JavaParam parameters = 4;
  repeated Variable type_parameters = 5;
  repeated Type signals = 6;
  required Statement body = 7;
  required ApplicableContract contract = 8;
}

message JavaParam {
  required int64 id = 1;
  required string origin = 2;
  repeated JavaModifier modifiers = 3;
  required string name = 4;
  required Type t = 5;
}

message JavaMethod {
  required string origin = 1;
  repeated JavaModifier modifiers = 2;
  required Type return_type = 3;
  required int32 dims = 4;
  required string name = 5;
  repeated JavaParam parameters = 6;
  repeated Variable type_parameters = 7;
  repeated Type signals = 8;
  optional Statement body = 9;
  required ApplicableContract contract = 10;
}

message JavaAnnotationMethod {
  required string origin = 1;
  required Type return_type = 2;
  required string name = 3;
  optional Expr default = 4;
}

message JavaLocalDeclaration {
  required int64 id = 1;
  required string origin = 2;
  repeated JavaModifier modifiers = 3;
  required Type t = 4;
  repeated JavaVariableDeclaration decls = 5;
}

message JavaBipGlueContainer {
  required string origin = 1;
  required Expr job = 2;
}

message BipGlue {
  required string origin = 1;
  repeated BipGlueRequires requires = 2;
  repeated BipGlueAccepts accepts = 3;
  repeated BipGlueDataWire data_wires = 4;
}

message BipIncomingData {
  required string origin = 1;
  required Type t = 2;
}

message BipOutgoingData {
  required string origin = 1;
  required Type t = 2;
  required Statement body = 3;
  required bool pure = 4;
}

message BipStatePredicate {
  required string origin = 1;
  required Expr expr = 2;
}

message BipTransition {
  required string origin = 1;
  required BipTransitionSignature signature = 2;
  required Ref port = 3;
  required Ref source = 4;
  required Ref target = 5;
  repeated Ref data = 6;
  required Expr guard = 7;
  required Expr requires = 8;
  required Expr ensures = 9;
  required Statement body = 10;
}

message BipGuard {
  required string origin = 1;
  repeated Ref data = 2;
  required Statement body = 3;
  required bool pure = 4;
}

message BipComponent {
  required string origin = 1;
  repeated string fqn = 2;
  repeated Ref constructors = 3;
  required Expr invariant = 4;
  required Ref initial = 5;
}

message BipPort {
  required string origin = 1;
  required BipPortType t = 2;
}

message BipPortSynchronization {
  required string origin = 1;
  repeated Ref ports = 2;
  repeated BipGlueDataWire wires = 3;
}

message BipTransitionSynchronization {
  required string origin = 1;
  repeated Ref transitions = 2;
  repeated BipGlueDataWire wires = 3;
}

message LlvmFunctionDefinition {
  required string origin = 1;
  required Type return_type = 2;
  repeated Variable args = 3;
  required Statement function_body = 4;
  required LlvmFunctionContract contract = 5;
  required bool pure = 6;
}

message PVLConstructor {
  required string origin = 1;
  required ApplicableContract contract = 2;
  repeated Variable args = 3;
  optional Statement body = 4;
}

message SilverField {
  required string origin = 1;
  required Type t = 2;
}

message Verification {
  required string origin = 1;
  repeated VerificationContext tasks = 2;
  required ExpectedErrors expected_errors = 3;
}

message VerificationContext {
  required string origin = 1;
  required Program program = 2;
}

message Program {
  required string origin = 1;
  repeated GlobalDeclaration declarations = 2;
}

message TNotAValue {
  required string origin = 1;
}

message TUnion {
  required string origin = 1;
  repeated Type types = 2;
}

message TArray {
  required string origin = 1;
  required Type element = 2;
}

message TPointer {
  required string origin = 1;
  required Type element = 2;
}

message TType {
  required string origin = 1;
  required Type t = 2;
}

message TVar {
  required string origin = 1;
  required Ref ref = 2;
}

message TSeq {
  required string origin = 1;
  required Type element = 2;
}

message TSet {
  required string origin = 1;
  required Type element = 2;
}

message TBag {
  required string origin = 1;
  required Type element = 2;
}

message TMap {
  required string origin = 1;
  required Type key = 2;
  required Type value = 3;
}

message TOption {
  required string origin = 1;
  required Type element = 2;
}

message TTuple {
  required string origin = 1;
  repeated Type elements = 2;
}

message TEither {
  required string origin = 1;
  required Type left = 2;
  required Type right = 3;
}

message TMatrix {
  required string origin = 1;
  required Type element = 2;
}

message TAny {
  required string origin = 1;
}

message TNothing {
  required string origin = 1;
}

message TVoid {
  required string origin = 1;
}

message TNull {
  required string origin = 1;
}

message TBool {
  required string origin = 1;
}

message TResource {
  required string origin = 1;
}

message TChar {
  required string origin = 1;
}

message TString {
  required string origin = 1;
}

message TRef {
  required string origin = 1;
}

message TProcess {
  required string origin = 1;
}

message TInt {
  required string origin = 1;
}

message TBoundedInt {
  required string origin = 1;
  required BigInt gte = 2;
  required BigInt lt = 3;
}

message TFloat {
  required string origin = 1;
  required int32 exponent = 2;
  required int32 mantissa = 3;
}

message TRational {
  required string origin = 1;
}

message TFraction {
  required string origin = 1;
}

message TZFraction {
  required string origin = 1;
}

message TModel {
  required string origin = 1;
  required Ref model = 2;
}

message TClass {
  required string origin = 1;
  required Ref cls = 2;
}

message TSeqProg {
  required string origin = 1;
  required Ref cls = 2;
}

message TVeyMontThread {
  required string origin = 1;
  required Ref cls = 2;
}

message TAnyClass {
  required string origin = 1;
}

message TAxiomatic {
  required string origin = 1;
  required Ref adt = 2;
  repeated Type args = 3;
}

message TEnum {
  required string origin = 1;
  required Ref enum = 2;
}

message TProverType {
  required string origin = 1;
  required Ref ref = 2;
}

message ParParallel {
  required string origin = 1;
  repeated ParRegion regions = 2;
}

message ParSequential {
  required string origin = 1;
  repeated ParRegion regions = 2;
}

message ParBlock {
  required string origin = 1;
  required ParBlockDecl decl = 2;
  repeated IterVariable iters = 3;
  required Expr context_everywhere = 4;
  required Expr requires = 5;
  required Expr ensures = 6;
  required Statement content = 7;
}

message LoopInvariant {
  required string origin = 1;
  required Expr invariant = 2;
  optional DecreasesClause decreases = 3;
}

message IterationContract {
  required string origin = 1;
  required Expr requires = 2;
  required Expr ensures = 3;
  required Expr context_everywhere = 4;
}

message CatchClause {
  required string origin = 1;
  required Variable decl = 2;
  required Statement body = 3;
}

message IterVariable {
  required string origin = 1;
  required Variable variable = 2;
  required Expr from = 3;
  required Expr to = 4;
}

message LocalDecl {
  required string origin = 1;
  required Variable local = 2;
}

message SpecIgnoreStart {
  required string origin = 1;
}

message SpecIgnoreEnd {
  required string origin = 1;
}

message Assign {
  required string origin = 1;
  required Expr target = 2;
  required Expr value = 3;
}

message Send {
  required string origin = 1;
  required SendDecl decl = 2;
  required BigInt delta = 3;
  required Expr res = 4;
}

message Recv {
  required string origin = 1;
  required Ref ref = 2;
}

message DefaultCase {
  required string origin = 1;
}

message Case {
  required string origin = 1;
  required Expr pattern = 2;
}

message Label {
  required string origin = 1;
  required LabelDecl decl = 2;
  required Statement stat = 3;
}

message Goto {
  required string origin = 1;
  required Ref lbl = 2;
}

message Exhale {
  required string origin = 1;
  required Expr res = 2;
}

message VctAssert {
  required string origin = 1;
  required Expr res = 2;
}

message Refute {
  required string origin = 1;
  required Expr assn = 2;
}

message Inhale {
  required string origin = 1;
  required Expr res = 2;
}

message Assume {
  required string origin = 1;
  required Expr assn = 2;
}

message Wait {
  required string origin = 1;
  required Expr obj = 2;
}

message Notify {
  required string origin = 1;
  required Expr obj = 2;
}

message Fork {
  required string origin = 1;
  required Expr obj = 2;
}

message Join {
  required string origin = 1;
  required Expr obj = 2;
}

message Lock {
  required string origin = 1;
  required Expr obj = 2;
}

message Unlock {
  required string origin = 1;
  required Expr obj = 2;
}

message Commit {
  required string origin = 1;
  required Expr obj = 2;
}

message Fold {
  required string origin = 1;
  required Expr res = 2;
}

message Unfold {
  required string origin = 1;
  required Expr res = 2;
}

message WandApply {
  required string origin = 1;
  required Expr res = 2;
}

message Havoc {
  required string origin = 1;
  required Expr loc = 2;
}

message FramedProof {
  required string origin = 1;
  required Expr pre = 2;
  required Statement body = 3;
  required Expr post = 4;
}

message Extract {
  required string origin = 1;
  required Statement contracted_statement = 2;
}

message Eval {
  required string origin = 1;
  required Expr expr = 2;
}

message InvokeProcedure {
  required string origin = 1;
  required Ref ref = 2;
  repeated Expr args = 3;
  repeated Expr out_args = 4;
  repeated Type type_args = 5;
  repeated RefExpr given_map = 6;
  repeated ExprRef yields = 7;
}

message InvokeMethod {
  required string origin = 1;
  required Expr obj = 2;
  required Ref ref = 3;
  repeated Expr args = 4;
  repeated Expr out_args = 5;
  repeated Type type_args = 6;
  repeated RefExpr given_map = 7;
  repeated ExprRef yields = 8;
}

message Return {
  required string origin = 1;
  required Expr result = 2;
}

message Throw {
  required string origin = 1;
  required Expr obj = 2;
}

message Break {
  required string origin = 1;
  optional Ref label = 2;
}

message Continue {
  required string origin = 1;
  optional Ref label = 2;
}

message Block {
  required string origin = 1;
  repeated Statement statements = 2;
}

message Scope {
  required string origin = 1;
  repeated Variable locals = 2;
  required Statement body = 3;
}

message Branch {
  required string origin = 1;
  repeated ExprStatement branches = 2;
}

message IndetBranch {
  required string origin = 1;
  repeated Statement branches = 2;
}

message Switch {
  required string origin = 1;
  required Expr expr = 2;
  required Statement body = 3;
}

message Loop {
  required string origin = 1;
  required Statement init = 2;
  required Expr cond = 3;
  required Statement update = 4;
  required LoopContract contract = 5;
  required Statement body = 6;
}

message TryCatchFinally {
  required string origin = 1;
  required Statement body = 2;
  required Statement after = 3;
  repeated CatchClause catches = 4;
}

message Synchronized {
  required string origin = 1;
  required Expr obj = 2;
  required Statement body = 3;
}

message ParInvariant {
  required string origin = 1;
  required ParInvariantDecl decl = 2;
  required Expr inv = 3;
  required Statement content = 4;
}

message ParAtomic {
  required string origin = 1;
  repeated Ref inv = 2;
  required Statement content = 3;
}

message ParBarrier {
  required string origin = 1;
  required Ref block = 2;
  repeated Ref invs = 3;
  required Expr requires = 4;
  required Expr ensures = 5;
  required Statement content = 6;
}

message ParStatement {
  required string origin = 1;
  required ParRegion impl = 2;
}

message VecBlock {
  required string origin = 1;
  repeated IterVariable iters = 2;
  required Expr requires = 3;
  required Expr ensures = 4;
  required Statement content = 5;
}

message WandPackage {
  required string origin = 1;
  required Expr res = 2;
  required Statement proof = 3;
}

message ModelDo {
  required string origin = 1;
  required Expr model = 2;
  required Expr perm = 3;
  required Expr after = 4;
  required Expr action = 5;
  required Statement impl = 6;
}

message SmtLib {
  required string origin = 1;
}

message Boogie {
  required string origin = 1;
}

message OperatorLeftPlus {
  required string origin = 1;
}

message OperatorRightPlus {
  required string origin = 1;
}

message SignalsClause {
  required string origin = 1;
  required Variable binding = 2;
  required Expr assn = 3;
}

message DecreasesClauseAssume {
  required string origin = 1;
}

message DecreasesClauseNoRecursion {
  required string origin = 1;
}

message DecreasesClauseTuple {
  required string origin = 1;
  repeated Expr exprs = 2;
}

message ApplicableContract {
  required string origin = 1;
  required AccountedPredicate requires = 2;
  required AccountedPredicate ensures = 3;
  required Expr context_everywhere = 4;
  repeated SignalsClause signals = 5;
  repeated Variable given_args = 6;
  repeated Variable yields_args = 7;
  optional DecreasesClause decreases = 8;
}

message UnitAccountedPredicate {
  required string origin = 1;
  required Expr pred = 2;
}

message SplitAccountedPredicate {
  required string origin = 1;
  required AccountedPredicate left = 2;
  required AccountedPredicate right = 3;
}

message Final {
  required string origin = 1;
}

message CoerceIdentity {
  required string origin = 1;
  required Type source = 2;
}

message CoercionSequence {
  required string origin = 1;
  repeated Coercion coercions = 2;
}

message CoerceNothingSomething {
  required string origin = 1;
  required Type target = 2;
}

message CoerceSomethingAny {
  required string origin = 1;
  required Type source = 2;
}

message CoerceJoinUnion {
  required string origin = 1;
  repeated Coercion inner = 2;
  repeated Type source = 3;
  required Type target = 4;
}

message CoerceSelectUnion {
  required string origin = 1;
  required Coercion inner = 2;
  required Type source = 3;
  repeated Type target_alts = 4;
  required int32 index = 5;
}

message CoerceBoolResource {
  required string origin = 1;
}

message CoerceNullRef {
  required string origin = 1;
}

message CoerceNullArray {
  required string origin = 1;
  required Type array_element_type = 2;
}

message CoerceNullClass {
  required string origin = 1;
  required Ref target_class = 2;
}

message CoerceNullJavaClass {
  required string origin = 1;
  required Ref target_class = 2;
}

message CoerceNullAnyClass {
  required string origin = 1;
}

message CoerceNullPointer {
  required string origin = 1;
  required Type pointer_element_type = 2;
}

message CoerceNullEnum {
  required string origin = 1;
  required Ref target_enum = 2;
}

message CoerceCArrayPointer {
  required string origin = 1;
  required Type element_type = 2;
}

message CoerceFracZFrac {
  required string origin = 1;
}

message CoerceZFracRat {
  required string origin = 1;
}

message CoerceFloatRat {
  required string origin = 1;
  required Type source = 2;
}

message CoerceIntRat {
  required string origin = 1;
}

message CoerceIncreasePrecision {
  required string origin = 1;
  required Type source = 2;
  required Type target = 3;
}

message CoerceWidenBound {
  required string origin = 1;
  required Type source = 2;
  required Type target = 3;
}

message CoerceUnboundInt {
  required string origin = 1;
  required Type source = 2;
}

message CoerceBoundIntFrac {
  required string origin = 1;
}

message CoerceBoundIntZFrac {
  required string origin = 1;
  required Type source = 2;
}

message CoerceBoundIntFloat {
  required string origin = 1;
  required Type source = 2;
  required Type target = 3;
}

message CoerceSupports {
  required string origin = 1;
  required Ref source_class = 2;
  required Ref target_class = 3;
}

message CoerceJavaSupports {
  required string origin = 1;
  required Ref source_class = 2;
  required Ref target_class = 3;
}

message CoerceClassAnyClass {
  required string origin = 1;
  required Ref source_class = 2;
}

message CoerceJavaClassAnyClass {
  required string origin = 1;
  required Ref source_class = 2;
}

message CoerceCPrimitiveToCol {
  required string origin = 1;
  required Type source = 2;
  required Type target = 3;
}

message CoerceColToCPrimitive {
  required string origin = 1;
  required Type source = 2;
  required Type target = 3;
}

message CoerceMapOption {
  required string origin = 1;
  required Coercion inner = 2;
  required Type source_option_element = 3;
  required Type target_option_element = 4;
}

message CoerceMapTuple {
  required string origin = 1;
  repeated Coercion inner = 2;
  repeated Type source_types = 3;
  repeated Type target_types = 4;
}

message CoerceMapEither {
  required string origin = 1;
  required CoercionCoercion inner = 2;
  required TypeType source_types = 3;
  required TypeType target_types = 4;
}

message CoerceMapSeq {
  required string origin = 1;
  required Coercion inner = 2;
  required Type source_seq_element = 3;
  required Type target_seq_element = 4;
}

message CoerceMapSet {
  required string origin = 1;
  required Coercion inner = 2;
  required Type source_set_element = 3;
  required Type target_set_element = 4;
}

message CoerceMapBag {
  required string origin = 1;
  required Coercion inner = 2;
  required Type source_bag_element = 3;
  required Type target_bag_element = 4;
}

message CoerceMapMatrix {
  required string origin = 1;
  required Coercion inner = 2;
  required Type source_matrix_element = 3;
  required Type target_matrix_element = 4;
}

message CoerceMapMap {
  required string origin = 1;
  required Coercion inner = 2;
  required TypeType source_types = 3;
  required TypeType target_types = 4;
}

message CoerceMapType {
  required string origin = 1;
  required Coercion inner = 2;
  required Type source_bound = 3;
  required Type target_bound = 4;
}

message CoerceRatZFrac {
  required string origin = 1;
}

message CoerceZFracFrac {
  required string origin = 1;
}

message IntegerValue {
  required string origin = 1;
  required BigInt value = 2;
}

message BooleanValue {
  required string origin = 1;
  required bool value = 2;
}

message FloatValue {
  required string origin = 1;
  required BigDecimal value = 2;
  required Type t = 3;
}

message StringValue {
  required string origin = 1;
  required string value = 2;
}

message CharValue {
  required string origin = 1;
  required int32 value = 2;
}

message LiteralSeq {
  required string origin = 1;
  required Type element = 2;
  repeated Expr values = 3;
}

message LiteralSet {
  required string origin = 1;
  required Type element = 2;
  repeated Expr values = 3;
}

message LiteralBag {
  required string origin = 1;
  required Type element = 2;
  repeated Expr values = 3;
}

message LiteralTuple {
  required string origin = 1;
  repeated Type ts = 2;
  repeated Expr values = 3;
}

message LiteralMap {
  required string origin = 1;
  required Type k = 2;
  required Type v = 3;
  repeated ExprExpr values = 4;
}

message UntypedLiteralSeq {
  required string origin = 1;
  repeated Expr values = 2;
}

message UntypedLiteralSet {
  required string origin = 1;
  repeated Expr values = 2;
}

message UntypedLiteralBag {
  required string origin = 1;
  repeated Expr values = 2;
}

message Void {
  required string origin = 1;
}

message Null {
  required string origin = 1;
}

message NoPerm {
  required string origin = 1;
}

message WritePerm {
  required string origin = 1;
}

message OptSome {
  required string origin = 1;
  required Expr e = 2;
}

message OptSomeTyped {
  required string origin = 1;
  required Type element = 2;
  required Expr e = 3;
}

message OptNone {
  required string origin = 1;
}

message OptNoneTyped {
  required string origin = 1;
  required Type element = 2;
}

message Range {
  required string origin = 1;
  required Expr from = 2;
  required Expr to = 3;
}

message EitherLeft {
  required string origin = 1;
  required Expr e = 2;
}

message EitherRight {
  required string origin = 1;
  required Expr e = 2;
}

message MapCons {
  required string origin = 1;
  required Expr map = 2;
  required Expr k = 3;
  required Expr v = 4;
}

message AmbiguousThis {
  required string origin = 1;
}

message ThisObject {
  required string origin = 1;
  required Ref cls = 2;
}

message ThisModel {
  required string origin = 1;
  required Ref cls = 2;
}

message ThisSeqProg {
  required string origin = 1;
  required Ref cls = 2;
}

message AmbiguousResult {
  required string origin = 1;
}

message Result {
  required string origin = 1;
  required Ref applicable = 2;
}

message CurrentThreadId {
  required string origin = 1;
}

message LocalThreadId {
  required string origin = 1;
}

message GlobalThreadId {
  required string origin = 1;
}

message Any {
  required string origin = 1;
}

message ReadPerm {
  required string origin = 1;
}

message Values {
  required string origin = 1;
  required Expr arr = 2;
  required Expr from = 3;
  required Expr to = 4;
}

message MapEq {
  required string origin = 1;
  required Expr left = 2;
  required Expr right = 3;
}

message MapDisjoint {
  required string origin = 1;
  required Expr left = 2;
  required Expr right = 3;
}

message MapKeySet {
  required string origin = 1;
  required Expr map = 2;
}

message MapValueSet {
  required string origin = 1;
  required Expr map = 2;
}

message MapItemSet {
  required string origin = 1;
  required Expr map = 2;
}

message MapRemove {
  required string origin = 1;
  required Expr map = 2;
  required Expr k = 3;
}

message Forall {
  required string origin = 1;
  repeated Variable bindings = 2;
  repeated SeqExpr triggers = 3;
  required Expr body = 4;
}

message Starall {
  required string origin = 1;
  repeated Variable bindings = 2;
  repeated SeqExpr triggers = 3;
  required Expr body = 4;
}

message Exists {
  required string origin = 1;
  repeated Variable bindings = 2;
  repeated SeqExpr triggers = 3;
  required Expr body = 4;
}

message Sum {
  required string origin = 1;
  repeated Variable bindings = 2;
  required Expr condition = 3;
  required Expr main = 4;
}

message Product {
  required string origin = 1;
  repeated Variable bindings = 2;
  required Expr condition = 3;
  required Expr main = 4;
}

message ForPerm {
  required string origin = 1;
  repeated Variable bindings = 2;
  required Location loc = 3;
  required Expr body = 4;
}

message ForPermWithValue {
  required string origin = 1;
  required Variable binding = 2;
  required Expr body = 3;
}

message Let {
  required string origin = 1;
  required Variable binding = 2;
  required Expr value = 3;
  required Expr main = 4;
}

message InlinePattern {
  required string origin = 1;
  required Expr inner = 2;
  required int32 parent = 3;
  required int32 group = 4;
}

message ScopedExpr {
  required string origin = 1;
  repeated Variable declarations = 2;
  required Expr body = 3;
}

message Local {
  required string origin = 1;
  required Ref ref = 2;
}

message EnumUse {
  required string origin = 1;
  required Ref enum = 2;
  required Ref const = 3;
}

message Deref {
  required string origin = 1;
  required Expr obj = 2;
  required Ref ref = 3;
}

message ModelDeref {
  required string origin = 1;
  required Expr obj = 2;
  required Ref ref = 3;
}

message DerefPointer {
  required string origin = 1;
  required Expr pointer = 2;
}

message DerefVeyMontThread {
  required string origin = 1;
  required Ref ref = 2;
}

message PointerAdd {
  required string origin = 1;
  required Expr pointer = 2;
  required Expr offset = 3;
}

message AddrOf {
  required string origin = 1;
  required Expr e = 2;
}

message FunctionOf {
  required string origin = 1;
  required Ref binding = 2;
  repeated Ref vars = 3;
}

message ApplyCoercion {
  required string origin = 1;
  required Expr e = 2;
  required Coercion coercion = 3;
}

message ADTFunctionInvocation {
  required string origin = 1;
  optional RefSeqType type_args = 2;
  required Ref ref = 3;
  repeated Expr args = 4;
}

message ProverFunctionInvocation {
  required string origin = 1;
  required Ref ref = 2;
  repeated Expr args = 3;
}

message PredicateApply {
  required string origin = 1;
  required Ref ref = 2;
  repeated Expr args = 3;
  required Expr perm = 4;
}

message InstancePredicateApply {
  required string origin = 1;
  required Expr obj = 2;
  required Ref ref = 3;
  repeated Expr args = 4;
  required Expr perm = 5;
}

message CoalesceInstancePredicateApply {
  required string origin = 1;
  required Expr obj = 2;
  required Ref ref = 3;
  repeated Expr args = 4;
  required Expr perm = 5;
}

message ProcedureInvocation {
  required string origin = 1;
  required Ref ref = 2;
  repeated Expr args = 3;
  repeated Expr out_args = 4;
  repeated Type type_args = 5;
  repeated RefExpr given_map = 6;
  repeated ExprRef yields = 7;
}

message MethodInvocation {
  required string origin = 1;
  required Expr obj = 2;
  required Ref ref = 3;
  repeated Expr args = 4;
  repeated Expr out_args = 5;
  repeated Type type_args = 6;
  repeated RefExpr given_map = 7;
  repeated ExprRef yields = 8;
}

message FunctionInvocation {
  required string origin = 1;
  required Ref ref = 2;
  repeated Expr args = 3;
  repeated Type type_args = 4;
  repeated RefExpr given_map = 5;
  repeated ExprRef yields = 6;
}

message InstanceFunctionInvocation {
  required string origin = 1;
  required Expr obj = 2;
  required Ref ref = 3;
  repeated Expr args = 4;
  repeated Type type_args = 5;
  repeated RefExpr given_map = 6;
  repeated ExprRef yields = 7;
}

message UMinus {
  required string origin = 1;
  required Expr arg = 2;
}

message BitNot {
  required string origin = 1;
  required Expr arg = 2;
}

message Not {
  required string origin = 1;
  required Expr arg = 2;
}

message AmbiguousMult {
  required string origin = 1;
  required Expr left = 2;
  required Expr right = 3;
}

message AmbiguousPlus {
  required string origin = 1;
  required Expr left = 2;
  required Expr right = 3;
}

message AmbiguousMinus {
  required string origin = 1;
  required Expr left = 2;
  required Expr right = 3;
}

message AmbiguousOr {
  required string origin = 1;
  required Expr left = 2;
  required Expr right = 3;
}

message AmbiguousComputationalOr {
  required string origin = 1;
  required Expr left = 2;
  required Expr right = 3;
}

message AmbiguousComputationalXor {
  required string origin = 1;
  required Expr left = 2;
  required Expr right = 3;
}

message AmbiguousComputationalAnd {
  required string origin = 1;
  required Expr left = 2;
  required Expr right = 3;
}

message ComputationalOr {
  required string origin = 1;
  required Expr left = 2;
  required Expr right = 3;
}

message ComputationalXor {
  required string origin = 1;
  required Expr left = 2;
  required Expr right = 3;
}

message ComputationalAnd {
  required string origin = 1;
  required Expr left = 2;
  required Expr right = 3;
}

message Exp {
  required string origin = 1;
  required Expr left = 2;
  required Expr right = 3;
}

message Plus {
  required string origin = 1;
  required Expr left = 2;
  required Expr right = 3;
}

message Minus {
  required string origin = 1;
  required Expr left = 2;
  required Expr right = 3;
}

message Mult {
  required string origin = 1;
  required Expr left = 2;
  required Expr right = 3;
}

message Div {
  required string origin = 1;
  required Expr left = 2;
  required Expr right = 3;
}

message FloorDiv {
  required string origin = 1;
  required Expr left = 2;
  required Expr right = 3;
}

message Mod {
  required string origin = 1;
  required Expr left = 2;
  required Expr right = 3;
}

message StringConcat {
  required string origin = 1;
  required Expr left = 2;
  required Expr right = 3;
}

message BitAnd {
  required string origin = 1;
  required Expr left = 2;
  required Expr right = 3;
}

message BitOr {
  required string origin = 1;
  required Expr left = 2;
  required Expr right = 3;
}

message BitXor {
  required string origin = 1;
  required Expr left = 2;
  required Expr right = 3;
}

message BitShl {
  required string origin = 1;
  required Expr left = 2;
  required Expr right = 3;
}

message BitShr {
  required string origin = 1;
  required Expr left = 2;
  required Expr right = 3;
}

message BitUShr {
  required string origin = 1;
  required Expr left = 2;
  required Expr right = 3;
}

message And {
  required string origin = 1;
  required Expr left = 2;
  required Expr right = 3;
}

message Or {
  required string origin = 1;
  required Expr left = 2;
  required Expr right = 3;
}

message Implies {
  required string origin = 1;
  required Expr left = 2;
  required Expr right = 3;
}

message Star {
  required string origin = 1;
  required Expr left = 2;
  required Expr right = 3;
}

message Wand {
  required string origin = 1;
  required Expr left = 2;
  required Expr right = 3;
}

message Scale {
  required string origin = 1;
  required Expr scale = 2;
  required Expr res = 3;
}

message ScaleByParBlock {
  required string origin = 1;
  required Ref block = 2;
  required Expr res = 3;
}

message VeyMontCondition {
  required string origin = 1;
  repeated RefExpr condition = 2;
}

message PolarityDependent {
  required string origin = 1;
  required Expr on_inhale = 2;
  required Expr on_exhale = 3;
}

message Unfolding {
  required string origin = 1;
  required Expr res = 2;
  required Expr body = 3;
}

message FieldLocation {
  required string origin = 1;
  required Expr obj = 2;
  required Ref field = 3;
}

message ModelLocation {
  required string origin = 1;
  required Expr obj = 2;
  required Ref field = 3;
}

message SilverFieldLocation {
  required string origin = 1;
  required Expr obj = 2;
  required Ref field = 3;
}

message ArrayLocation {
  required string origin = 1;
  required Expr array = 2;
  required Expr subscript = 3;
}

message PointerLocation {
  required string origin = 1;
  required Expr pointer = 2;
}

message PredicateLocation {
  required string origin = 1;
  required Ref predicate = 2;
  repeated Expr args = 3;
}

message InstancePredicateLocation {
  required string origin = 1;
  required Ref predicate = 2;
  required Expr obj = 3;
  repeated Expr args = 4;
}

message AmbiguousLocation {
  required string origin = 1;
  required Expr expr = 2;
}

message Perm {
  required string origin = 1;
  required Location loc = 2;
  required Expr perm = 3;
}

message PointsTo {
  required string origin = 1;
  required Location loc = 2;
  required Expr perm = 3;
  required Expr value = 4;
}

message CurPerm {
  required string origin = 1;
  required Location loc = 2;
}

message Value {
  required string origin = 1;
  required Location loc = 2;
}

message ValidArray {
  required string origin = 1;
  required Expr arr = 2;
  required Expr len = 3;
}

message ValidMatrix {
  required string origin = 1;
  required Expr mat = 2;
  required Expr w = 3;
  required Expr h = 4;
}

message PermPointer {
  required string origin = 1;
  required Expr p = 2;
  required Expr len = 3;
  required Expr perm = 4;
}

message PermPointerIndex {
  required string origin = 1;
  required Expr p = 2;
  required Expr idx = 3;
  required Expr perm = 4;
}

message Eq {
  required string origin = 1;
  required Expr left = 2;
  required Expr right = 3;
}

message Neq {
  required string origin = 1;
  required Expr left = 2;
  required Expr right = 3;
}

message AmbiguousGreater {
  required string origin = 1;
  required Expr left = 2;
  required Expr right = 3;
}

message AmbiguousLess {
  required string origin = 1;
  required Expr left = 2;
  required Expr right = 3;
}

message AmbiguousGreaterEq {
  required string origin = 1;
  required Expr left = 2;
  required Expr right = 3;
}

message AmbiguousLessEq {
  required string origin = 1;
  required Expr left = 2;
  required Expr right = 3;
}

message Greater {
  required string origin = 1;
  required Expr left = 2;
  required Expr right = 3;
}

message Less {
  required string origin = 1;
  required Expr left = 2;
  required Expr right = 3;
}

message GreaterEq {
  required string origin = 1;
  required Expr left = 2;
  required Expr right = 3;
}

message LessEq {
  required string origin = 1;
  required Expr left = 2;
  required Expr right = 3;
}

message SubSet {
  required string origin = 1;
  required Expr left = 2;
  required Expr right = 3;
}

message SubSetEq {
  required string origin = 1;
  required Expr left = 2;
  required Expr right = 3;
}

message SubBag {
  required string origin = 1;
  required Expr left = 2;
  required Expr right = 3;
}

message SubBagEq {
  required string origin = 1;
  required Expr left = 2;
  required Expr right = 3;
}

message Select {
  required string origin = 1;
  required Expr condition = 2;
  required Expr when_true = 3;
  required Expr when_false = 4;
}

message NewObject {
  required string origin = 1;
  required Ref cls = 2;
}

message NewArray {
  required string origin = 1;
  required Type element = 2;
  repeated Expr dims = 3;
  required int32 more_dims = 4;
}

message Old {
  required string origin = 1;
  required Expr expr = 2;
  optional Ref at = 3;
}

message AmbiguousSubscript {
  required string origin = 1;
  required Expr collection = 2;
  required Expr index = 3;
}

message SeqSubscript {
  required string origin = 1;
  required Expr seq = 2;
  required Expr index = 3;
}

message ArraySubscript {
  required string origin = 1;
  required Expr arr = 2;
  required Expr index = 3;
}

message PointerSubscript {
  required string origin = 1;
  required Expr pointer = 2;
  required Expr index = 3;
}

message Length {
  required string origin = 1;
  required Expr arr = 2;
}

message Size {
  required string origin = 1;
  required Expr obj = 2;
}

message PointerBlockLength {
  required string origin = 1;
  required Expr pointer = 2;
}

message PointerBlockOffset {
  required string origin = 1;
  required Expr pointer = 2;
}

message PointerLength {
  required string origin = 1;
  required Expr pointer = 2;
}

message SharedMemSize {
  required string origin = 1;
  required Expr pointer = 2;
}

message NdIndex {
  required string origin = 1;
  repeated Expr indices = 2;
  repeated Expr dimensions = 3;
}

message NdPartialIndex {
  required string origin = 1;
  repeated Expr indices = 2;
  required Expr linear_index = 3;
  repeated Expr dimensions = 4;
}

message NdLength {
  required string origin = 1;
  repeated Expr dimensions = 2;
}

message Cons {
  required string origin = 1;
  required Expr x = 2;
  required Expr xs = 3;
}

message Head {
  required string origin = 1;
  required Expr xs = 2;
}

message Tail {
  required string origin = 1;
  required Expr xs = 2;
}

message Drop {
  required string origin = 1;
  required Expr xs = 2;
  required Expr count = 3;
}

message Take {
  required string origin = 1;
  required Expr xs = 2;
  required Expr count = 3;
}

message Slice {
  required string origin = 1;
  required Expr xs = 2;
  required Expr from = 3;
  required Expr to = 4;
}

message SeqUpdate {
  required string origin = 1;
  required Expr xs = 2;
  required Expr i = 3;
  required Expr x = 4;
}

message Concat {
  required string origin = 1;
  required Expr xs = 2;
  required Expr ys = 3;
}

message RemoveAt {
  required string origin = 1;
  required Expr xs = 2;
  required Expr i = 3;
}

message VctEmpty {
  required string origin = 1;
  required Expr obj = 2;
}

message SetIntersection {
  required string origin = 1;
  required Expr xs = 2;
  required Expr ys = 3;
}

message BagLargestCommon {
  required string origin = 1;
  required Expr xs = 2;
  required Expr ys = 3;
}

message SetMinus {
  required string origin = 1;
  required Expr xs = 2;
  required Expr ys = 3;
}

message BagMinus {
  required string origin = 1;
  required Expr xs = 2;
  required Expr ys = 3;
}

message SetUnion {
  required string origin = 1;
  required Expr xs = 2;
  required Expr ys = 3;
}

message BagAdd {
  required string origin = 1;
  required Expr xs = 2;
  required Expr ys = 3;
}

message AmbiguousMember {
  required string origin = 1;
  required Expr x = 2;
  required Expr xs = 3;
}

message SetMember {
  required string origin = 1;
  required Expr x = 2;
  required Expr xs = 3;
}

message SeqMember {
  required string origin = 1;
  required Expr x = 2;
  required Expr xs = 3;
}

message MapMember {
  required string origin = 1;
  required Expr x = 2;
  required Expr xs = 3;
}

message BagMemberCount {
  required string origin = 1;
  required Expr x = 2;
  required Expr xs = 3;
}

message Permutation {
  required string origin = 1;
  required Expr xs = 2;
  required Expr ys = 3;
}

message OptEmpty {
  required string origin = 1;
  required Expr opt = 2;
}

message OptGet {
  required string origin = 1;
  required Expr opt = 2;
}

message OptGetOrElse {
  required string origin = 1;
  required Expr opt = 2;
  required Expr alt = 3;
}

message MapGet {
  required string origin = 1;
  required Expr map = 2;
  required Expr k = 3;
}

message TupGet {
  required string origin = 1;
  required Expr tup = 2;
  required int32 index = 3;
}

message GetLeft {
  required string origin = 1;
  required Expr either = 2;
}

message GetRight {
  required string origin = 1;
  required Expr either = 2;
}

message IsLeft {
  required string origin = 1;
  required Expr either = 2;
}

message IsRight {
  required string origin = 1;
  required Expr either = 2;
}

message VectorSum {
  required string origin = 1;
  required Expr indices = 2;
  required Expr vec = 3;
}

message VectorCompare {
  required string origin = 1;
  required Expr left = 2;
  required Expr right = 3;
}

message VectorRepeat {
  required string origin = 1;
  required Expr e = 2;
}

message MatrixSum {
  required string origin = 1;
  required Expr indices = 2;
  required Expr mat = 3;
}

message MatrixCompare {
  required string origin = 1;
  required Expr left = 2;
  required Expr right = 3;
}

message MatrixRepeat {
  required string origin = 1;
  required Expr e = 2;
}

message CastFloat {
  required string origin = 1;
  required Expr e = 2;
  required Type t = 3;
}

message TypeValue {
  required string origin = 1;
  required Type value = 2;
}

message TypeOf {
  required string origin = 1;
  required Expr expr = 2;
}

message VctInstanceOf {
  required string origin = 1;
  required Expr value = 2;
  required Expr type_value = 3;
}

message Cast {
  required string origin = 1;
  required Expr value = 2;
  required Expr type_value = 3;
}

message SubType {
  required string origin = 1;
  required Expr left = 2;
  required Expr right = 3;
}

message SuperType {
  required string origin = 1;
  required Expr left = 2;
  required Expr right = 3;
}

message IndeterminateInteger {
  required string origin = 1;
  required Expr min = 2;
  required Expr max = 3;
}

message VeyMontCommExpression {
  required string origin = 1;
  required Ref receiver = 2;
  required Ref sender = 3;
  required Statement assign = 4;
}

message VeyMontAssignExpression {
  required string origin = 1;
  required Ref thread = 2;
  required Statement assign = 3;
}

message PreAssignExpression {
  required string origin = 1;
  required Expr target = 2;
  required Expr value = 3;
}

message PostAssignExpression {
  required string origin = 1;
  required Expr target = 2;
  required Expr value = 3;
}

message With {
  required string origin = 1;
  required Statement pre = 2;
  required Expr value = 3;
}

message Then {
  required string origin = 1;
  required Expr value = 2;
  required Statement post = 3;
}

message Held {
  required string origin = 1;
  required Expr obj = 2;
}

message Committed {
  required string origin = 1;
  required Expr obj = 2;
}

message IdleToken {
  required string origin = 1;
  required Expr thread = 2;
}

message JoinToken {
  required string origin = 1;
  required Expr thread = 2;
}

message EmptyProcess {
  required string origin = 1;
}

message ActionApply {
  required string origin = 1;
  required Ref action = 2;
  repeated Expr args = 3;
}

message ProcessApply {
  required string origin = 1;
  required Ref process = 2;
  repeated Expr args = 3;
}

message ProcessSeq {
  required string origin = 1;
  required Expr left = 2;
  required Expr right = 3;
}

message ProcessChoice {
  required string origin = 1;
  required Expr left = 2;
  required Expr right = 3;
}

message ProcessPar {
  required string origin = 1;
  required Expr left = 2;
  required Expr right = 3;
}

message ProcessSelect {
  required string origin = 1;
  required Expr cond = 2;
  required Expr when_true = 3;
  required Expr when_false = 4;
}

message ModelNew {
  required string origin = 1;
  required Ref ref = 2;
}

message ModelState {
  required string origin = 1;
  required Expr model = 2;
  required Expr perm = 3;
  required Expr state = 4;
}

message ModelAbstractState {
  required string origin = 1;
  required Expr model = 2;
  required Expr state = 3;
}

message ModelCreate {
  required string origin = 1;
  required Expr model = 2;
  required Expr init = 3;
}

message ModelDestroy {
  required string origin = 1;
  required Expr model = 2;
}

message ModelSplit {
  required string origin = 1;
  required Expr model = 2;
  required Expr left_perm = 3;
  required Expr left_process = 4;
  required Expr right_perm = 5;
  required Expr right_process = 6;
}

message ModelMerge {
  required string origin = 1;
  required Expr model = 2;
  required Expr left_perm = 3;
  required Expr left_process = 4;
  required Expr right_perm = 5;
  required Expr right_process = 6;
}

message ModelChoose {
  required string origin = 1;
  required Expr model = 2;
  required Expr perm = 3;
  required Expr total_process = 4;
  required Expr choice = 5;
}

message ModelPerm {
  required string origin = 1;
  required Expr loc = 2;
  required Expr perm = 3;
}

message ActionPerm {
  required string origin = 1;
  required Expr loc = 2;
  required Expr perm = 3;
}

message TSmtlibArray {
  required string origin = 1;
  repeated Type index = 2;
  required Type value = 3;
}

message TSmtlibBitVector {
  required string origin = 1;
  required int32 size = 2;
}

message TSmtlibRoundingMode {
  required string origin = 1;
}

message TSmtlibFloatingPoint {
  required string origin = 1;
  required int32 exponent_bits = 2;
  required int32 mantissa_and_sign_bits = 3;
}

message TSmtlibString {
  required string origin = 1;
}

message TSmtlibRegLan {
  required string origin = 1;
}

message TSmtlibSeq {
  required string origin = 1;
  required Type element = 2;
}

message SmtlibADTFunctionSymbol {
  required string origin = 1;
  required Ref ref = 2;
}

message SmtlibProverFunctionSymbol {
  required string origin = 1;
  required Ref ref = 2;
}

message SmtlibSelect {
  required string origin = 1;
  required Expr arr = 2;
  repeated Expr is = 3;
}

message SmtlibStore {
  required string origin = 1;
  required Expr arr = 2;
  repeated Expr is = 3;
  required Expr x = 4;
}

message SmtlibBitvecLiteral {
  required string origin = 1;
  required BitString data = 2;
}

message SmtlibConcat {
  required string origin = 1;
  required Expr left = 2;
  required Expr right = 3;
}

message SmtlibExtract {
  required string origin = 1;
  required int32 inclusive_end_index_from_right = 2;
  required int32 start_index_from_right = 3;
  required Expr bv = 4;
}

message SmtlibBvNot {
  required string origin = 1;
  required Expr bv = 2;
}

message SmtlibBvAnd {
  required string origin = 1;
  required Expr left = 2;
  required Expr right = 3;
}

message SmtlibBvOr {
  required string origin = 1;
  required Expr left = 2;
  required Expr right = 3;
}

message SmtlibBvNeg {
  required string origin = 1;
  required Expr bv = 2;
}

message SmtlibBvAdd {
  required string origin = 1;
  required Expr left = 2;
  required Expr right = 3;
}

message SmtlibBvMul {
  required string origin = 1;
  required Expr left = 2;
  required Expr right = 3;
}

message SmtlibBvUDiv {
  required string origin = 1;
  required Expr left = 2;
  required Expr right = 3;
}

message SmtlibBvURem {
  required string origin = 1;
  required Expr left = 2;
  required Expr right = 3;
}

message SmtlibBvShl {
  required string origin = 1;
  required Expr left = 2;
  required Expr right = 3;
}

message SmtlibBvShr {
  required string origin = 1;
  required Expr left = 2;
  required Expr right = 3;
}

message SmtlibBvULt {
  required string origin = 1;
  required Expr left = 2;
  required Expr right = 3;
}

message SmtlibRNE {
  required string origin = 1;
}

message SmtlibRNA {
  required string origin = 1;
}

message SmtlibRTP {
  required string origin = 1;
}

message SmtlibRTN {
  required string origin = 1;
}

message SmtlibRTZ {
  required string origin = 1;
}

message SmtlibFp {
  required string origin = 1;
  required Expr sign = 2;
  required Expr exponent = 3;
  required Expr mantissa = 4;
}

message SmtlibFpAbs {
  required string origin = 1;
  required Expr arg = 2;
}

message SmtlibFpNeg {
  required string origin = 1;
  required Expr arg = 2;
}

message SmtlibFpAdd {
  required string origin = 1;
  required Expr left = 2;
  required Expr right = 3;
}

message SmtlibFpSub {
  required string origin = 1;
  required Expr left = 2;
  required Expr right = 3;
}

message SmtlibFpMul {
  required string origin = 1;
  required Expr left = 2;
  required Expr right = 3;
}

message SmtlibFpDiv {
  required string origin = 1;
  required Expr left = 2;
  required Expr right = 3;
}

message SmtlibFpFma {
  required string origin = 1;
  required Expr left = 2;
  required Expr right = 3;
  required Expr addend = 4;
}

message SmtlibFpSqrt {
  required string origin = 1;
  required Expr arg = 2;
}

message SmtlibFpRem {
  required string origin = 1;
  required Expr left = 2;
  required Expr right = 3;
}

message SmtlibFpRoundToIntegral {
  required string origin = 1;
  required Expr arg = 2;
}

message SmtlibFpMin {
  required string origin = 1;
  required Expr left = 2;
  required Expr right = 3;
}

message SmtlibFpMax {
  required string origin = 1;
  required Expr left = 2;
  required Expr right = 3;
}

message SmtlibFpLeq {
  required string origin = 1;
  required Expr left = 2;
  required Expr right = 3;
}

message SmtlibFpLt {
  required string origin = 1;
  required Expr left = 2;
  required Expr right = 3;
}

message SmtlibFpGeq {
  required string origin = 1;
  required Expr left = 2;
  required Expr right = 3;
}

message SmtlibFpGt {
  required string origin = 1;
  required Expr left = 2;
  required Expr right = 3;
}

message SmtlibFpEq {
  required string origin = 1;
  required Expr left = 2;
  required Expr right = 3;
}

message SmtlibFpIsNormal {
  required string origin = 1;
  required Expr arg = 2;
}

message SmtlibFpIsSubnormal {
  required string origin = 1;
  required Expr arg = 2;
}

message SmtlibFpIsZero {
  required string origin = 1;
  required Expr arg = 2;
}

message SmtlibFpIsInfinite {
  required string origin = 1;
  required Expr arg = 2;
}

message SmtlibFpIsNaN {
  required string origin = 1;
  required Expr arg = 2;
}

message SmtlibFpIsNegative {
  required string origin = 1;
  required Expr arg = 2;
}

message SmtlibFpIsPositive {
  required string origin = 1;
  required Expr arg = 2;
}

message SmtlibToFp {
  required string origin = 1;
  required Expr bv = 2;
  required int32 exponent_bits = 3;
  required int32 mantissa_and_sign_bits = 4;
}

message SmtlibFpCast {
  required string origin = 1;
  required Expr arg = 2;
  required int32 exponent_bits = 3;
  required int32 mantissa_and_sign_bits = 4;
}

message SmtlibFpFromReal {
  required string origin = 1;
  required Expr arg = 2;
  required int32 exponent_bits = 3;
  required int32 mantissa_and_sign_bits = 4;
}

message SmtlibFpFromSInt {
  required string origin = 1;
  required Expr bv = 2;
  required int32 exponent_bits = 3;
  required int32 mantissa_and_sign_bits = 4;
}

message SmtlibFpFromUInt {
  required string origin = 1;
  required Expr bv = 2;
  required int32 exponent_bits = 3;
  required int32 mantissa_and_sign_bits = 4;
}

message SmtlibFpToReal {
  required string origin = 1;
  required Expr arg = 2;
}

message SmtlibFpToSInt {
  required string origin = 1;
  required Expr arg = 2;
  required int32 bits = 3;
}

message SmtlibFpToUInt {
  required string origin = 1;
  required Expr arg = 2;
  required int32 bits = 3;
}

message SmtlibLiteralString {
  required string origin = 1;
  required string data = 2;
}

message SmtlibStrConcat {
  required string origin = 1;
  required Expr left = 2;
  required Expr right = 3;
}

message SmtlibStrLen {
  required string origin = 1;
  required Expr arg = 2;
}

message SmtlibStrLt {
  required string origin = 1;
  required Expr left = 2;
  required Expr right = 3;
}

message SmtlibStrLeq {
  required string origin = 1;
  required Expr left = 2;
  required Expr right = 3;
}

message SmtlibStrAt {
  required string origin = 1;
  required Expr str = 2;
  required Expr i = 3;
}

message SmtlibSubstr {
  required string origin = 1;
  required Expr str = 2;
  required Expr i = 3;
  required Expr n = 4;
}

message SmtlibStrPrefixOf {
  required string origin = 1;
  required Expr left = 2;
  required Expr right = 3;
}

message SmtlibStrSuffixOf {
  required string origin = 1;
  required Expr left = 2;
  required Expr right = 3;
}

message SmtlibStrContains {
  required string origin = 1;
  required Expr left = 2;
  required Expr right = 3;
}

message SmtlibStrIndexOf {
  required string origin = 1;
  required Expr haystack = 2;
  required Expr needle = 3;
  required Expr from_index = 4;
}

message SmtlibStrReplace {
  required string origin = 1;
  required Expr haystack = 2;
  required Expr needle = 3;
  required Expr replacement = 4;
}

message SmtlibStrReplaceAll {
  required string origin = 1;
  required Expr haystack = 2;
  required Expr needle = 3;
  required Expr replacement = 4;
}

message SmtlibStrReplaceRe {
  required string origin = 1;
  required Expr haystack = 2;
  required Expr re = 3;
  required Expr replacement = 4;
}

message SmtlibStrReplaceReAll {
  required string origin = 1;
  required Expr haystack = 2;
  required Expr re = 3;
  required Expr replacement = 4;
}

message SmtlibStrIsDigit {
  required string origin = 1;
  required Expr arg = 2;
}

message SmtlibStrToCode {
  required string origin = 1;
  required Expr arg = 2;
}

message SmtlibStrFromCode {
  required string origin = 1;
  required Expr arg = 2;
}

message SmtlibStrToInt {
  required string origin = 1;
  required Expr arg = 2;
}

message SmtlibStrFromInt {
  required string origin = 1;
  required Expr arg = 2;
}

message SmtlibReFromStr {
  required string origin = 1;
  required Expr arg = 2;
}

message SmtlibReContains {
  required string origin = 1;
  required Expr re = 2;
  required Expr str = 3;
}

message SmtlibReNone {
  required string origin = 1;
}

message SmtlibReAll {
  required string origin = 1;
}

message SmtlibReAllChar {
  required string origin = 1;
}

message SmtlibReConcat {
  required string origin = 1;
  required Expr left = 2;
  required Expr right = 3;
}

message SmtlibReUnion {
  required string origin = 1;
  required Expr left = 2;
  required Expr right = 3;
}

message SmtlibReInter {
  required string origin = 1;
  required Expr left = 2;
  required Expr right = 3;
}

message SmtlibReStar {
  required string origin = 1;
  required Expr arg = 2;
}

message SmtlibReComp {
  required string origin = 1;
  required Expr arg = 2;
}

message SmtlibReDiff {
  required string origin = 1;
  required Expr left = 2;
  required Expr right = 3;
}

message SmtlibRePlus {
  required string origin = 1;
  required Expr arg = 2;
}

message SmtlibReOpt {
  required string origin = 1;
  required Expr arg = 2;
}

message SmtlibReRange {
  required string origin = 1;
  required Expr left = 2;
  required Expr right = 3;
}

message SmtlibReRepeat {
  required string origin = 1;
  required int32 count = 2;
  required Expr arg = 3;
}

message SmtlibReRepeatRange {
  required string origin = 1;
  required int32 from = 2;
  required int32 to = 3;
  required Expr arg = 4;
}

message Z3BvSub {
  required string origin = 1;
  required Expr left = 2;
  required Expr right = 3;
}

message Z3BvSRem {
  required string origin = 1;
  required Expr left = 2;
  required Expr right = 3;
}

message Z3BvSMod {
  required string origin = 1;
  required Expr left = 2;
  required Expr right = 3;
}

message Z3BvSShr {
  required string origin = 1;
  required Expr left = 2;
  required Expr right = 3;
}

message Z3BvNand {
  required string origin = 1;
  required Expr left = 2;
  required Expr right = 3;
}

message Z3BvNor {
  required string origin = 1;
  required Expr left = 2;
  required Expr right = 3;
}

message Z3BvXnor {
  required string origin = 1;
  required Expr left = 2;
  required Expr right = 3;
}

message Z3ArrayConst {
  required string origin = 1;
  repeated Type domain = 2;
  required Type codomain = 3;
  required Expr value = 4;
}

message Z3ArrayOfFunction {
  required string origin = 1;
  required SmtlibFunctionSymbol ref = 2;
}

message Z3ArrayMap {
  required string origin = 1;
  required SmtlibFunctionSymbol ref = 2;
  repeated Expr args = 3;
}

message Z3SeqEmpty {
  required string origin = 1;
  required Type element_type = 2;
}

message Z3SeqUnit {
  required string origin = 1;
  required Expr arg = 2;
}

message Z3SeqConcat {
  required string origin = 1;
  required Expr left = 2;
  required Expr right = 3;
}

message Z3SeqLen {
  required string origin = 1;
  required Expr arg = 2;
}

message Z3SeqExtract {
  required string origin = 1;
  required Expr seq = 2;
  required Expr offset = 3;
  required Expr len = 4;
}

message Z3SeqAt {
  required string origin = 1;
  required Expr seq = 2;
  required Expr offset = 3;
}

message Z3SeqNth {
  required string origin = 1;
  required Expr seq = 2;
  required Expr offset = 3;
}

message Z3SeqContains {
  required string origin = 1;
  required Expr seq = 2;
  required Expr subseq = 3;
}

message Z3SeqPrefixOf {
  required string origin = 1;
  required Expr pre = 2;
  required Expr subseq = 3;
}

message Z3SeqSuffixOf {
  required string origin = 1;
  required Expr post = 2;
  required Expr seq = 3;
}

message Z3SeqReplace {
  required string origin = 1;
  required Expr haystack = 2;
  required Expr needle = 3;
  required Expr replacement = 4;
}

message Z3SeqMap {
  required string origin = 1;
  required Expr f = 2;
  required Expr seq = 3;
}

message Z3SeqMapI {
  required string origin = 1;
  required Expr f = 2;
  required Expr offset = 3;
  required Expr seq = 4;
}

message Z3SeqFoldl {
  required string origin = 1;
  required Expr f = 2;
  required Expr base = 3;
  required Expr seq = 4;
}

message Z3SeqFoldlI {
  required string origin = 1;
  required Expr f = 2;
  required Expr offset = 3;
  required Expr base = 4;
  required Expr seq = 5;
}

message Z3TransitiveClosure {
  required string origin = 1;
  required SmtlibFunctionSymbol ref = 2;
  repeated Expr args = 3;
}

message CPure {
  required string origin = 1;
}

message CInline {
  required string origin = 1;
}

message CTypedef {
  required string origin = 1;
}

message CExtern {
  required string origin = 1;
}

message CStatic {
  required string origin = 1;
}

message GPULocal {
  required string origin = 1;
}

message GPUGlobal {
  required string origin = 1;
}

message CVoid {
  required string origin = 1;
}

message CChar {
  required string origin = 1;
}

message CShort {
  required string origin = 1;
}

message CInt {
  required string origin = 1;
}

message CLong {
  required string origin = 1;
}

message CSigned {
  required string origin = 1;
}

message CUnsigned {
  required string origin = 1;
}

message CBool {
  required string origin = 1;
}

message CTypedefName {
  required string origin = 1;
  required string name = 2;
}

message CSpecificationType {
  required string origin = 1;
  required Type t = 2;
}

message CTypeQualifierDeclarationSpecifier {
  required string origin = 1;
  required CTypeQualifier type_qual = 2;
}

message CConst {
  required string origin = 1;
}

message CRestrict {
  required string origin = 1;
}

message CVolatile {
  required string origin = 1;
}

message CAtomic {
  required string origin = 1;
}

message CUDAKernel {
  required string origin = 1;
}

message OpenCLKernel {
  required string origin = 1;
}

message CPointer {
  required string origin = 1;
  repeated CTypeQualifier qualifiers = 2;
}

message CPointerDeclarator {
  required string origin = 1;
  repeated CPointer pointers = 2;
  required CDeclarator inner = 3;
}

message CArrayDeclarator {
  required string origin = 1;
  repeated CTypeQualifier qualifiers = 2;
  optional Expr size = 3;
  required CDeclarator inner = 4;
}

message CTypedFunctionDeclarator {
  required string origin = 1;
  repeated CParam params = 2;
  required bool varargs = 3;
  required CDeclarator inner = 4;
}

message CAnonymousFunctionDeclarator {
  required string origin = 1;
  repeated string params = 2;
  required CDeclarator inner = 3;
}

message CName {
  required string origin = 1;
  required string name = 2;
}

message CInit {
  required string origin = 1;
  required CDeclarator decl = 2;
  optional Expr init = 3;
}

message CDeclaration {
  required string origin = 1;
  required ApplicableContract contract = 2;
  required Expr kernel_invariant = 3;
  repeated CDeclarationSpecifier specs = 4;
  repeated CInit inits = 5;
}

message CDeclarationStatement {
  required string origin = 1;
  required CLocalDeclaration decl = 2;
}

message CGoto {
  required string origin = 1;
  required string label = 2;
}

message GpuLocalMemoryFence {
  required string origin = 1;
}

message GpuGlobalMemoryFence {
  required string origin = 1;
}

message GpuZeroMemoryFence {
  required string origin = 1;
  required BigInt value = 2;
}

message GpgpuBarrier {
  required string origin = 1;
  required Expr requires = 2;
  required Expr ensures = 3;
  repeated GpuMemoryFence specifiers = 4;
}

message GpgpuAtomic {
  required string origin = 1;
  required Statement impl = 2;
  required Statement before = 3;
  required Statement after = 4;
}

message CLocal {
  required string origin = 1;
  required string name = 2;
}

message CInvocation {
  required string origin = 1;
  required Expr applicable = 2;
  repeated Expr args = 3;
  repeated RefExpr given_args = 4;
  repeated ExprRef yields = 5;
}

message CStructAccess {
  required string origin = 1;
  required Expr struct = 2;
  required string field = 3;
}

message CStructDeref {
  required string origin = 1;
  required Expr struct = 2;
  required string field = 3;
}

message GpgpuCudaKernelInvocation {
  required string origin = 1;
  required string kernel = 2;
  required Expr blocks = 3;
  required Expr threads = 4;
  repeated Expr args = 5;
  repeated RefExpr given_args = 6;
  repeated ExprRef yields = 7;
}

message CCast {
  required string origin = 1;
  required Expr expr = 2;
  required Type t = 3;
}

message CPrimitiveType {
  required string origin = 1;
  repeated CDeclarationSpecifier specifiers = 2;
}

message CTPointer {
  required string origin = 1;
  required Type inner_type = 2;
}

message CTArray {
  required string origin = 1;
  optional Expr size = 2;
  required Type inner_type = 3;
}

message CTCudaVec {
  required string origin = 1;
}

message JavaName {
  required string origin = 1;
  repeated string names = 2;
}

message JavaImport {
  required string origin = 1;
  required bool is_static = 2;
  required JavaName name = 3;
  required bool star = 4;
}

message JavaPublic {
  required string origin = 1;
}

message JavaProtected {
  required string origin = 1;
}

message JavaPrivate {
  required string origin = 1;
}

message JavaStatic {
  required string origin = 1;
}

message JavaAbstract {
  required string origin = 1;
}

message JavaFinal {
  required string origin = 1;
}

message JavaStrictFP {
  required string origin = 1;
}

message JavaNative {
  required string origin = 1;
}

message JavaSynchronized {
  required string origin = 1;
}

message JavaTransient {
  required string origin = 1;
}

message JavaVolatile {
  required string origin = 1;
}

message JavaAnnotation {
  required string origin = 1;
  required Type name = 2;
  repeated StringExpr args = 3;
}

message JavaPure {
  required string origin = 1;
}

message JavaInline {
  required string origin = 1;
}

message JavaBipAnnotation {
  required string origin = 1;
}

message JavaVariableDeclaration {
  required string origin = 1;
  required string name = 2;
  required int32 more_dims = 3;
  optional Expr init = 4;
}

message JavaLocalDeclarationStatement {
  required string origin = 1;
  required JavaLocalDeclaration decl = 2;
}

message JavaNamedType {
  required string origin = 1;
  repeated StringOptSeqType names = 2;
}

message JavaTClass {
  required string origin = 1;
  required Ref ref = 2;
  repeated Type type_args = 3;
}

message JavaWildcard {
  required string origin = 1;
}

message JavaLocal {
  required string origin = 1;
  required string name = 2;
}

message JavaDeref {
  required string origin = 1;
  required Expr obj = 2;
  required string field = 3;
}

message JavaLiteralArray {
  required string origin = 1;
  repeated Expr exprs = 2;
}

message JavaInvocation {
  required string origin = 1;
  optional Expr obj = 2;
  repeated Type type_params = 3;
  required string method = 4;
  repeated Expr arguments = 5;
  repeated RefExpr given_args = 6;
  repeated ExprRef yields = 7;
}

message JavaNewClass {
  required string origin = 1;
  repeated Expr args = 2;
  repeated Type type_args = 3;
  required Type name = 4;
  repeated RefExpr given_args = 5;
  repeated ExprRef yields = 6;
}

message JavaNewLiteralArray {
  required string origin = 1;
  required Type base_type = 2;
  required int32 dims = 3;
  required Expr initializer = 4;
}

message JavaNewDefaultArray {
  required string origin = 1;
  required Type base_type = 2;
  repeated Expr specified_dims = 3;
  required int32 more_dims = 4;
}

message JavaStringValue {
  required string origin = 1;
  required string data = 2;
  required Type t = 3;
}

message JavaBipGlue {
  required string origin = 1;
  repeated JavaBipGlueElement elems = 2;
}

message JavaBipGlueName {
  required string origin = 1;
  required Type t = 2;
  required Expr e = 3;
}

message JavaBipGlueRequires {
  required string origin = 1;
  required JavaBipGlueName port = 2;
  repeated JavaBipGlueName others = 3;
}

message JavaBipGlueAccepts {
  required string origin = 1;
  required JavaBipGlueName port = 2;
  repeated JavaBipGlueName others = 3;
}

message JavaBipGlueSynchron {
  required string origin = 1;
  required JavaBipGlueName port0 = 2;
  required JavaBipGlueName port1 = 3;
}

message JavaBipGlueDataWire {
  required string origin = 1;
  required JavaBipGlueName data_out = 2;
  required JavaBipGlueName data_in = 3;
}

message BipGlueRequires {
  required string origin = 1;
  required Ref port = 2;
  repeated Ref others = 3;
}

message BipGlueAccepts {
  required string origin = 1;
  required Ref port = 2;
  repeated Ref others = 3;
}

message BipGlueDataWire {
  required string origin = 1;
  required Ref data_out = 2;
  required Ref data_in = 3;
}

message BipLocalIncomingData {
  required string origin = 1;
  required Ref ref = 2;
}

message BipTransitionSignature {
  required string origin = 1;
  required string port_name = 2;
  required string source_state_name = 3;
  required string target_state_name = 4;
  optional string textual_guard = 5;
}

message BipGuardInvocation {
  required string origin = 1;
  required Expr obj = 2;
  required Ref guard = 3;
}

message BipEnforceable {
  required string origin = 1;
}

message BipSpontaneous {
  required string origin = 1;
}

message BipInternal {
  required string origin = 1;
}

message LlvmFunctionContract {
  required string origin = 1;
  required string value = 2;
  repeated StringRef references = 3;
}

message LlvmFunctionInvocation {
  required string origin = 1;
  required Ref ref = 2;
  repeated Expr args = 3;
  repeated RefExpr given_map = 4;
  repeated ExprRef yields = 5;
}

message LlvmLoop {
  required string origin = 1;
  required Expr cond = 2;
  required LlvmLoopContract contract = 3;
  required Statement body = 4;
}

message LlvmLoopInvariant {
  required string origin = 1;
  required string value = 2;
  repeated StringRef references = 3;
}

message PVLNamedType {
  required string origin = 1;
  required string name = 2;
  repeated Type type_args = 3;
}

message PVLLocal {
  required string origin = 1;
  required string name = 2;
}

message PVLDeref {
  required string origin = 1;
  required Expr obj = 2;
  required string field = 3;
}

message PVLInvocation {
  required string origin = 1;
  optional Expr obj = 2;
  required string method = 3;
  repeated Expr args = 4;
  repeated Type type_args = 5;
  repeated RefExpr given_map = 6;
  repeated ExprRef yields = 7;
}

message PVLNew {
  required string origin = 1;
  required Type t = 2;
  repeated Expr args = 3;
  repeated RefExpr given_map = 4;
  repeated ExprRef yields = 5;
}

message SilverDeref {
  required string origin = 1;
  required Expr obj = 2;
  required Ref field = 3;
}

message SilverIntToRat {
  required string origin = 1;
  required Expr perm = 2;
}

message SilverNull {
  required string origin = 1;
}

message SilverSeqSize {
  required string origin = 1;
  required Expr seq = 2;
}

message SilverSetSize {
  required string origin = 1;
  required Expr set = 2;
}

message SilverBagSize {
  required string origin = 1;
  required Expr bag = 2;
}

message SilverMapSize {
  required string origin = 1;
  required Expr map = 2;
}

message SilverCurFieldPerm {
  required string origin = 1;
  required Expr obj = 2;
  required Ref field = 3;
}

message SilverCurPredPerm {
  required string origin = 1;
  required Ref ref = 2;
  repeated Expr args = 3;
}

message SilverPartialADTFunctionInvocation {
  required string origin = 1;
  required string name = 2;
  repeated Expr args = 3;
  repeated RefType partial_type_args = 4;
}

message SilverUntypedNonemptyLiteralMap {
  required string origin = 1;
  repeated ExprExpr values = 2;
}

message SilverNewRef {
  required string origin = 1;
  required Ref v = 2;
  repeated Ref fields = 3;
}

message SilverFieldAssign {
  required string origin = 1;
  required Expr obj = 2;
  required Ref field = 3;
  required Expr value = 4;
}

message SilverLocalAssign {
  required string origin = 1;
  required Ref v = 2;
  required Expr value = 3;
}

message SilverPartialTAxiomatic {
  required string origin = 1;
  required Ref ref = 2;
  repeated RefType partial_type_args = 3;
}

message SeqExpr {
  repeated Expr v = 1;
}

message RefExpr {
  required Ref v1 = 1;
  required Expr v2 = 2;
}

message TypeType {
  required Type v1 = 1;
  required Type v2 = 2;
}

message StringExpr {
  required string v1 = 1;
  required Expr v2 = 2;
}

message ExprStatement {
  required Expr v1 = 1;
  required Statement v2 = 2;
}

message ProverLanguageString {
  required ProverLanguage v1 = 1;
  required string v2 = 2;
}

message RefSeqType {
  required Ref v1 = 1;
  repeated Type v2 = 2;
}

message SeqType {
  repeated Type v = 1;
}

message ExprExpr {
  required Expr v1 = 1;
  required Expr v2 = 2;
}

message ExprRef {
  required Expr v1 = 1;
  required Ref v2 = 2;
}

message StringRef {
  required string v1 = 1;
  required Ref v2 = 2;
}

message CoercionCoercion {
  required Coercion v1 = 1;
  required Coercion v2 = 2;
}

message StringOptSeqType {
  required string v1 = 1;
  optional SeqType v2 = 2;
}

message RefType {
  required Ref v1 = 1;
  required Type v2 = 2;
}
